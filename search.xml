<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[140款Android开源优秀项目源码-菜鸟窝]]></title>
      <url>%2F2017%2F05%2F10%2F140%E6%AC%BEAndroid%E5%BC%80%E6%BA%90%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81-%E8%8F%9C%E9%B8%9F%E7%AA%9D%2F</url>
      <content type="text"><![CDATA[开源项目 BeautifulRefreshLayout-漂亮的美食下拉刷新https://github.com/android-cjj/BeautifulRefreshLayout/tree/BeautifulRefreshForFood Material Design-动画风格的选项卡tab切换功能https://github.com/neokree/MaterialTabs TwinklingRefreshLayout-支持下拉刷新和上拉加载的RefreshLayout,自带越界回弹效果https://github.com/lcodecorex/TwinklingRefreshLayout DialogLoadding-Android开发之常用的loading等待效果实现，仿微博等待动画。两种实现方式详解https://github.com/QQ986945193/DialogLoadding owspace-完整高仿单读的APP，模仿得非常精美，基于MVP+Dagger2+Retrofit2.0+Rxjavahttps://github.com/babylikebird/owspace GSYVideoPlayer-android视频播放器，支持基本的拖动，声音、亮度调节，支持边播边缓存https://github.com/CarGuo/GSYVideoPlayer NumberKeyboard-仿造android端闲鱼发布选择价格数字键盘自定义数字键盘https://github.com/xuejinwei/NumberKeyboard SwipeRecyclerView-自定义下拉刷新上拉加载控件SwipeRefreshLayout+recyclerViewhttps://github.com/niniloveyou/SwipeRecyclerView FloatingView-android能够让View执行漂亮的漂浮动画的库https://github.com/UFreedom/FloatingView TyperEditText-Android仿业问打字机效果，很炫酷https://github.com/andyxialm/TyperEditText CircularMenu-android自动绘制遥控器界面CircularMenuhttps://github.com/sungerk/CircularMenu/ ConnectListView-ConnectListView联动,listView三级联动https://github.com/maning0303/ConnectListView DylanStepCount-Android精准计步器(小米,魅族,华为上可用)https://github.com/linglongxin24/DylanStepCount MultiType-FilePicker-MultiType-FilePicker-android一款轻量级的文件选择器,支持多种文件类型https://github.com/fishwjy/MultiType-FilePicker SuperTextView-一个功能强大的TextView,可以满足日常大部分布局方式https://github.com/lygttpod/SuperTextView Android-SpinKit-Android-SpinKit多个漂亮的加载效果https://github.com/ybq/Android-SpinKit PullToRefreshAndLoadMore-一个轻量下拉刷新上拉加载更多控件，已封装ListViewhttps://github.com/woxingxiao/PullToRefreshAndLoadMore BluetoothHelper-安卓蓝牙操作库，把蓝牙请求封装像Http一样https://github.com/a-voyager/BluetoothHelper Luban-android最接近微信朋友圈的图片压缩算法https://github.com/Curzibn/Luban CBDialog-android一个快速创建对话框的工具类库https://github.com/yilylong/CBDialog UserGuideView-androidy应用实现用户指引viewhttps://github.com/yilylong/UserGuideView okhttp一个让网络请求更简单的框架https://github.com/jeasonlzy/okhttp-OkGo TwinklingRefreshLayout-下拉刷新和上拉加载的RefreshLayout,自带越界回弹效果,支持RecyclerView,AbsListView,ScrollView,WebViewhttps://github.com/lcodecorex/TwinklingRefreshLayout StickerCamera-android一款集成了相机,图片裁剪,给图片贴贴图打标签的APPhttps://github.com/Skykai521/StickerCamera AndroidFire-一款新闻阅读App框架基于Material Desighttps://github.com/jaydenxiao2016/AndroidFire ViewPagerCards-android ViewPagerCards卡片切换效果源码https://github.com/rubensousa/ViewPagerCards Douya-Material Design 的豆芽客户端完整源码https://github.com/DreaminginCodeZH/Douya RestAPP-android网易云音乐界面源码https://github.com/sakurajiang/RestAPP huabanDemo-android 应用material design版的花瓣网Apphttps://github.com/LiCola/huabanDemo slidingtutorial-android-slidingtutorial-android创建视差效果引导页的库自定义强使用简单https://github.com/Cleveroad/slidingtutorial-android DropDownMenu-android实用的多条件筛选菜单,非popupWindow实现无卡顿https://github.com/dongjunkun/DropDownMenu CouponView-android开发半圆锯齿背景虚线边框组合实现简单优惠券效果https://github.com/dongjunkun/CouponView Tuikan-一款集知乎头条,美图，视频于一体的休闲阅读app源码https://github.com/homcin/Tuikan UPMiss-andoorid一个完整的生日管理Apphttps://github.com/qiujuer/UPMiss DropDownMenu-android完整的筛选器解决方案DropDownMenuhttps://github.com/baiiu/DropDownMenu StepView-android物流跟踪指示器StepViewhttps://github.com/baoyachi/StepView StylishMusicPlayer-一个超棒的Android Music Player源码https://github.com/ryanhoo/StylishMusicPlayer MaterialTabs-Material Design动画风格的选项卡tab切换功能https://github.com/neokree/MaterialTabs GankWithZhihu-阅读类App（MVP + RxJava + Retrofit）https://github.com/Werb/GankWithZhihu MyCalendarDemo-一款Android日历提醒软件https://github.com/Werb/MyCalendarDemo MaterialHome-基于Material Design的图书展示类完整app采用的是MD设计风格https://github.com/hymanme/MaterialHome UpdateDemo-android app自动检测更新库https://github.com/hugeterry/UpdateDemo TaoSchool-android一款基于Material Desgin设计的APPhttps://github.com/Hankkin/TaoSchool RecyclerViewCardGallery-android使用RecyclerView实现Gallery画廊效果https://github.com/huazhiyuan2008/RecyclerViewCardGallery/ CKCamera-android一个拍照并裁剪拍出照片的项目https://github.com/ChrisKyle/CKCamera SuperIndicator-android SuperIndicator 广告轮播源码https://github.com/hejunlin2013/SuperIndicator SignUpAnimation-android一个绚丽的注册动画界面https://github.com/qike2015/SignUpAnimation XRecyclerView-andorid RecyclerView下拉刷新，上拉加载更多https://github.com/jianghejie/XRecyclerView AutoInstaller-android应用自动下载静默安装https://github.com/a-voyager/AutoInstaller SeatTable-android在线电影票选座Demohttps://github.com/qifengdeqingchen/SeatTable android-adDialog-android一个简单强大的广告活动弹窗控件https://github.com/yipianfengye/android-adDialog Android-FilePicker-android图片和文档选择器https://github.com/DroidNinja/Android-FilePicker ViewPagerCards-android卡片切换效果ViewPagerCardshttps://github.com/rubensousa/ViewPagerCards/ CoCoin-一款完整的记账app(附带源码)https://github.com/Nightonke/CoCoin AndroidReview-一款面向Android开发者的一款面试复习Apphttps://github.com/envyfan/AndroidReview Douya-开源Material Design豆瓣客户端源码https://github.com/DreaminginCodeZH/Douya android脑筋急转弯（完整数据版）源码http://pan.baidu.com/s/1c17AWXM zkw6 DateScroller-探索日期滚轮控件的源码https://github.com/SpikeKing/DateScroller ZLayoutManager-五行代码实现 炫动滑动 卡片层叠布局，仿探探、人人影视订阅界面 简单&amp;优雅：LayoutManager+ItemTouchHelperhttps://github.com/mcxtzhang/ZLayoutManager RNPolymerPo-基于 React Native 的 Android 企业级应用 Demo。https://github.com/yanbober/RNPolymerPo BoomMenu-漂亮的菜单弹出控件 BoomMenuhttps://github.com/Nightonke/BoomMenu MobileSafe-MobileSafe 是一个下载过两万并且非常适合初学者学习的项目(没错就是黑马手机卫士)https://github.com/JessYanCoding/MobileSafe KuaiChuan-仿茄子快传的一款文件传输应用https://github.com/mayubao/KuaiChuan SImageView-一个实用方便的图片控件SImageViewhttps://github.com/suzeyu1992/SImageView WowSplash-不规则扩散的splashhttps://github.com/githubwing/WowSplash android-FancyBehaviorDemo-使用 CoordinatorLayout 实现复杂联动效果https://github.com/unixzii/android-FancyBehaviorDemo LbaizxfPulltoRefresh-仿健客、京东、天猫下拉刷新加载动画实现https://github.com/leibing8912/LbaizxfPulltoRefresh ZoomHeader-饿了么是怎么让Image变成详情页的https://github.com/githubwing/ZoomHeader XDroid-轻量级Android快速开发框架https://github.com/limedroid/XDroid CustomTextLayout-Android自定义组合控件（标题栏+组合布局）非常强大https://github.com/ithedan/CustomTextLayout QQ-高仿腾讯QQ，代码十分优雅https://github.com/HuTianQi/QQ YingBeautyNote-订个小目标，写个印象笔记https://github.com/HuTianQi/YingBeautyNote ZuiMeiTAG-用recyclerView实现最美应用底栏https://github.com/huage2580/ZuiMeiTAG ZuiMeiTAG-深入探索通知与插件的实时刷新https://github.com/SpikeKing/TimerAppWidget AnimationMenu-android 软软的动画弹出菜单，基于Facebook的Rebuondhttps://github.com/CarGuo/AnimationMenu WaveView-高仿百度外卖个人中心，让你的界面和我一起浪起来https://github.com/1139618418/WaveView shopcar-仿饿了么购物车下单效果https://github.com/917386389/shopcar RxJavaRetrofitOkhttpMvp-时下流行的RxJava+Retrofit+Okhttp+Mvp封装的一个demohttps://github.com/gslovemy/RxJavaRetrofitOkhttpMvp BitmapWaveView-安卓自定义View在bitmap中玩转大波浪进度https://github.com/AndroidMsky/BitmapWaveView Android-PickerView-Library-Android高仿ios pickerViewhttps://github.com/Airsaid/Android-PickerView-Library CustomNavigatorBar-Android通用标题栏组合控件https://github.com/wangluAndroid/CustomNavigatorBar SwipeDelMenuLayout-史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOShttps://github.com/mcxtzhang/SwipeDelMenuLayout DragFooterView-向左拖拽跳转至“更多页面”的通用控件https://github.com/uin3566/DragFooterView VRefreshLayout-Android下拉刷新控件之header置顶显示效果https://github.com/ileelay/VRefreshLayout TransitionHelper-两步实现类似格瓦拉的转场动画https://github.com/ImmortalZ/TransitionHelper DialogFragment-自定义对话框应该这样写https://github.com/GitPhoenix/DialogFragment RefreshLayout-RefreshLayout让你半小时以内完成一个列表界面https://github.com/gengqiquan/RefreshLayout SwipeCardRecyclerView-如何利用RecyclerView打造炫酷滑动卡片https://github.com/HalfStackDeveloper/SwipeCardRecyclerView LookLook-一个小时打造新闻apphttps://github.com/xinghongfei/LookLook JPTabBar-一款强大的Android底部导航https://github.com/peng8350/JPTabBar ByeBurger-炫酷：一句代码实现标题栏、导航栏滑动隐藏，ByeBurger库的使用和实现https://github.com/githubwing/ByeBurger CommonRecycler-通用 RecylerAdapter，内置 XRecyclerView，兼容上下拉与动画，高复用，一个 Adapter 通用所有页面，支持空页面，懒人专属https://github.com/CarGuo/CommonRecycler FreeBook-先定一个小目标!比如说先用MVP和快速开发框架打造一个免费下载小说的app老司机来手把手教你半天搞定https://github.com/80945540/FreeBook IjkPlayerView-基于ijkplayer的视频播放器，仿Bilibili客户端，集成沉浸式全屏、弹幕、触屏控制、视频源切换等功能https://github.com/Rukey7/IjkPlayerView CoolImageView-非常酷的图片组件，类似腾讯 QQ 可以让 imageview 的图片背景上下移动，或左右移动https://github.com/HuTianQi/CoolImageView AWelcomeVideoPager-ndroid酷炫欢迎页播放视频,仿蚂蜂窝自由行和慕课网https://github.com/linglongxin24/WelcomeVideoPager validateui-一个表单验证的libhttps://github.com/LongMaoC/validateui CollapseView-Android仿安居客房源详情页图片显示https://github.com/xiaoqiAndroid/CollapseView/tree/master HintPopupWindow-比QQ更炫酷的’选项弹窗’动画https://github.com/Zhaoss/HintPopupWindow RecyclerViewDemo2- 精通RecyclerView：打造ListView、GridView、瀑布流；学会添加分割线、 添加删除动画 、Item点击事件https://github.com/linglongxin24/RecyclerViewDemo2 TinderStackView-Android高仿「陌陌」的点点效果https://github.com/Mersens/TinderStackView MvpDemo-优雅的构建Android项目之 MVP开发模式https://github.com/PandaQAQ/MvpDemo Material Animations -演示View的平移、缩放动画，activity进入和退出动画，界面间元素共享，并且开发者在README中，对动画原理进行了精讲，是学习动画很好的项目，项目代码量比较少，也很适合新手学习。https://github.com/lgvalle/Material-Animations Meizhi-每天推送一张妹子图、一个小视频和一系列程序员精选文章，数据来源于代码家的干货集中营。唯一不足就是视频解析还有bug，声音视频无法同步，希望能尽快修复。https://github.com/drakeet/Meizhi android-UniversalMusicPlayer-这个开源项目展示了如何实现一个横跨各种Android平台的音乐播放器，包括手机，平板，汽车，手表，电视等。Google官方推出，跨平台开发必看项目。https://github.com/googlesamples/android-UniversalMusicPlayer plaid-由谷歌工程师开发，展示Google Material风格设计，项目代码量大，但是结构清晰，还是很好理解的。https://github.com/nickbutcher/plaid CalendarView-Android 滚轮日期选择自定义Viewhttps://github.com/chenpengfei88/CalendarView AndroidMVPSample-一套完整的Android通用框架https://github.com/WuXiaolong/AndroidMVPSample CoordinatorLayoutTest-高仿支付宝9.9.2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayouthttps://github.com/jack921/CoordinatorLayoutTest SideSlip_PullToRefresh-Android 集成了RecyclerView 刷新加载，及侧滑菜单的 PullToRefreshhttps://github.com/lvfaqiang/SideSlip_PullToRefresh SideSlip_PullToRefresh-通用Android标题栏控件https://github.com/xiaohaibin/CustomTitileBar CalendarView-Android 自定义价格日历控件https://github.com/yissan/CalendarView ZhiHuDaily-纸飞机-采用MVP架构，集合了知乎日报、果壳精选和豆瓣一刻的综合性阅读客户端https://github.com/marktony/ZhiHuDaily ZhiHuDaily-仅2步实现 拜拜 汉堡导航栏效果~ 全新底部导航交互(滑动隐藏)https://github.com/githubwing/ByeBurger FloatBubbleView-Android：会呼吸的悬浮气泡https://github.com/IamXiaRui/Android_5.0_ViewDemo/tree/master/FloatBubbleView ByeBurger-极其简便的快速实现滑动隐藏标题栏和导航栏https://github.com/githubwing/ByeBurger NotificationUtil-全新的Android通知栏,已抛弃setLatestEventInfo,兼容高版本https://github.com/linglongxin24/NotificationUtil LauncherView-十分钟搞定酷炫动画，Android自定义 View 入门https://github.com/diamondlin2016/LauncherView LiveShow-使用MVP+RxJava制作的笑话APPhttps://github.com/GaoGersy/LiveShow ChargeProgress-android 自定义view+属性动画实现充电进度条功能https://github.com/crazyandcoder/ChargeProgress Notes-炫酷的ViewPager动画效果https://github.com/Elder-Wu/Notes ElasticLayout-超轻量！安卓实现多item抽屉效果动画https://github.com/AndroidMsky/ElasticLayout SuperTextView-SuperTextView 一款强大的android TextViewhttps://github.com/lygttpod/SuperTextView SuperTextView-自定义LayoutManager实现一个展示文章的View，支持拖动插入以及相应的动画展示https://github.com/rantianhua/AssembleEssay VideoRecord-Android 拍摄（横 \ 竖屏）视频的懒人之路https://github.com/CarGuo/VideoRecord Telegram-著名IM应用Telegram源码https://github.com/DrKLO/Telegram Notes-自定义View系列：未读消息数角标https://github.com/Elder-Wu/Notes BeautifulWords-Android开源实战：使用MVP+Retrofit开发一款文字阅读APPhttps://github.com/zuiwuyuan/BeautifulWords Notes-自定义ViewPager——左右无限循环，带指示器https://github.com/Elder-Wu/Notes Myprogress-安卓Android多阶段进度条progress bar附带动画效果https://github.com/AndroidMsky/Myprogress SpannableStringBiulderTest-直接拿去用！几种常见Dialog，懒人必收https://github.com/weavey/NormalSelectDialog SpannableStringBiulderTest-【Android】强大的SpannableStringBuilderhttps://github.com/Gavin-ZYX/SpannableStringBiulderTest Ghost-微影，一款纯粹的在线视频App，基于Material Design + MVP + RxJava + Retrofit + Realm + Glidehttps://github.com/GeekGhost/Ghost SwipeRecyclerView-自定义下拉刷新上拉加载控件（SwipeRefreshLayout + recyclerView）https://github.com/niniloveyou/SwipeRecyclerView ViewDragHelperDemo-Android自定义ViewGroup神器-ViewDragHelperhttps://github.com/hiphonezhu/Android-Demos/tree/master/ViewDragHelperDemo UserDefinedProgressBar-好玩的动画加载和自定义ProgressBarhttps://github.com/junmei520/UserDefinedProgressBar MPermissionUtils-Android6.0 运行时权限 超轻量级工具类https://github.com/Airsaid/MPermissionUtils EmptyLayout-Android通用的EmptyLayout-展示不用状态的界面https://github.com/yewei02538/EmptyLayout NestFullListView-【Android】ListView、RecyclerView、ScrollView里嵌套ListView 相对优雅的解决方案:NestFullListViewhttps://github.com/mcxtzhang/NestFullListView WindowMenuDemo-Android仿Qzone底部导航栏加号弹出菜单https://github.com/MjCodeTinker/WindowMenuDemo SmileRefresh-微笑下拉刷新。这是在 SwipeRefreshLayout基础上修改的下拉刷新库。https://github.com/songixan/SmileRefresh MyCartDemo-Android自定义View–自己撸一个柱状图也没那么难https://github.com/Hankkin/MyCartDemo MDStudySamples-Android TabLayout 分分钟打造一个滑动标签页https://github.com/Mike-bel/MDStudySamples WingUE-基本特效：饿了么丝滑无缝过度搜索栏的实现https://github.com/githubwing/WingUE 史上最牛逼的音乐播放器—仿网易云音乐（已开源）https://github.com/aa112901/remusic GABottleLoading-贝塞尔风暴 － 超炫GABottleLoading效果https://github.com/Ajian-studio/GABottleLoading PathAnimView-【注释张豪华版 Path酷炫动画】极速get花式Path （支付宝支付成功动画）https://github.com/mcxtzhang/PathAnimView Material Design : 带动画的标题栏https://github.com/shiguiyou/MaterialDemo/tree/master MultiTypeAdapter-优雅的实现多类型列表的Adapterhttps://github.com/LiHongHui6/MultiTypeAdapter AnimationPlayer-探索View动画和属性动画https://github.com/SpikeKing/AnimationPlayer AnimShopButton-仿饿了么加入购物车旋转控件 - 自带闪转腾挪动画 的按钮https://github.com/mcxtzhang/AnimShopButton YinyuetaiPlayer-高仿音悦台播放页面交互效果https://github.com/oubowu/YinyuetaiPlayer AndroidAnimationExercise-Android 动画实战 - 仿微博雷达功能https://github.com/REBOOTERS/AndroidAnimationExercise]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用工具]]></title>
      <url>%2F2017%2F04%2F25%2F%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[个人收藏，常用链接。 智联招聘xenderzd423XX-NethostsSwitchHostsretrolambdaYUtilsGoAgentcheckstylehexo-theme-nexthexogfwssRxJava-collectionTrinea open-projectTrinea android-commonCircleImageViewdaimajia AndroidSwipeLayoutRxAndroidMaterialDesignLibraryatom.ioatomunbug codelfJakeWharton ViewPagerIndicatorzxingfastJsonstormzhangreact-nativedagger2EventBuslanternshadowsocks-windowsglidegreenDAOdagger1okhttppicassobutterkniferetrofitgfw.pressopen-android AndroidbaseAdapterleakcanaryRxJavaSwitchyOmegagoproxyairmore]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中国大陆版权协议]]></title>
      <url>%2F2017%2F04%2F24%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E7%89%88%E6%9D%83%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[支持知识产权保护，尊重知识创造，该文本包含知识共享和许可协议中的部分相关概念和一些链接。 题目： 署名-非商业性使用-相同方式共享 3.0 中国大陆 (CC BY-NC-SA 3.0 CN) 正文： 您可以自由地： 共享 — 在任何媒介以任何形式复制、发行本作品 演绎 — 修改、转换或以本作品为基础进行创作 只要你遵守许可协议条款，许可人就无法收回你的这些权利。 惟须遵守下列条件： 署名 — 您必须给出合适的 姓名或名称，提供许可协议链接，同时表明如果有修改。您可以合理的方式这样做，但是部分以任何方式暗示许可人同意您或您的使用。 非商业性使用 — 您不得将本作品用于商业目的。相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。 没有附加限制 — 您不得适用法律术语或者技术措施 从而限制其他人做许可协议允许的事情。 声明： 您不必因为公共领域的作品要素而遵守许可协议，或者您的使用被可适用的例外或限制所允许。 不提供担保。许可协议可能不会给与您意图使用的所必须的所有许可。例如，其他权利比如形象权、隐私权或人格权 可能限制您如何使用作品。 知识共享 许可协议]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[即时通讯]]></title>
      <url>%2F2017%2F04%2F24%2F%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%2F</url>
      <content type="text"><![CDATA[即时通讯： IM 环信： 基础版，日活 30 万，免费。 PaaS 不生产实体产品（app），提供服务平台。app 服务器，用户信息的服务器，是开发软件自己的服务器， 环信只提供一个服务平台，通信通道。 数据安全，自己的服务器平台融云：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简述 23 种设计模式]]></title>
      <url>%2F2017%2F04%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[写博客的初衷是以学习、记录、交流为主，文章中的思路是参照 Java开发中的23种设计模式详解，并加入了自己的一些思考和总结,参照的文章也是转载的，并指向 CSDN 博主终点，但未找到相应的文章，特此说明。 知乎中有框架与设计模式的区别的介绍。 分类总体分为 3 大类： 创建型模式：有 5 种，工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式：有 7 种，适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式：有 11 种，策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 六大原则开闭原则（Open Close Principle）对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，类似于热插拔。 这是为了使程序具有扩展性，易于维护和升级。而想要达到这样的效果，我们需要使用接口和抽象类。 tips ：重构，代码不够好的时候，也可以考虑重构， but 有成本。扩展， 一代代码不够好的话，扩展相当于打补丁。 所以： 重构 + 基类 + 接口扩展 里氏代换原则 LSP Liskov Substitution Principle 面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现 “开-闭原则” 的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现， 里氏代换原则是对实现抽象化的具体步骤的规范。 tip： 扩展/衍生类/子类 前提：基类功能不受影响 手段：要复用基类功能 目的：扩展/增加新功能、新特性 依赖倒转原则 Dependence Inversion Principle 这是开闭原则的基础，具体内容：针对接口编程、依赖于抽象而不依赖于具体。 tips：针对接口或者基类编程，高层次代码不能依赖低层次代码 接口隔离原则 Interface Segregation Principle 使用多个隔离的接口，比使用单个接口要好。有降低类之间耦合度的意思。 设计模式的设计思想是从大型软件架构出发，为了升级和维护方便。降低依赖，降低耦合。 tips ：接口过多也不方便管理，适用即可。高内聚，低耦合： 高内聚指的是单个类结构，是类的内部特征；低耦合指的是类与类之间的关系，是类的外部特征。 迪米特法则(最少知道原则) Demeter Principle 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 tips：不主动依赖，用构造传接口或者对象比 new 对象要好，new 对象是非原子性操作，耦合并没有被消灭，只是被转移到了接口或者基类上 3 种解耦合的注入方式：构造注入，接口注入， setter 注入。 合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 tips： 抽象/接口是最基础的，也是整体上的思想，而合成是将一些已经有的模块组合成为新的模块功能，而不是一味的去创建继承是有条件有代价的，继承是对已有功能的扩展但这种继承关系本身也是一种耦合，设计所能做的是减少耦合，或者松耦合，或者转移耦合方式，而不是消灭耦合 耦合本身指的是两个同类（比如说模块）之间的紧密程度，在 Android 中可以理解为两个类之间的关系，当设计可以让类与类之间的紧密关系降低时，我们就可以说是降低了耦合度，但实际上又和基类或者接口耦合了，这种耦合可以视为一种规范或者标准化。 高内聚，低耦合： 是指模块内部的功能单一，模块与模块间的紧密关系小。前者是指模块内部的关系，后者是指模块之间关系，两者不矛盾。 设计模式 1. 工厂方法： 3 种方式 共同的接口 public interface Sender { public void Send(); } 实现类 1 public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } 实现类 2 public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 普通工厂类 –&gt; 方式1 public class SendFactory { public Sender produce(String type) { if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 多个工厂方法的工厂类 –&gt; 方式 2 public Sender produceMail() { return new MailSender(); } public Sender produceSms() { return new SmsSender(); } 静态工厂方法的工厂类 –&gt; 方式 3 public class SendFactory { public static Sender produceMail() { return new MailSender(); } public static Sender produceSms() { return new SmsSender(); } } 总体来说，简单工厂模式（工厂方法）适合： 凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。 在以上的三种模式中 第一种如果传入的字符串有误，不能正确创建对象 第三种相对于第二种，不需要实例化工厂类。 大多数情况下，我们会选用第三种 ——&gt; [静态工厂方法模式]。 抽象工厂模式（Abstract Factory）工厂方法模式有一个问题就是，类的创建依赖工厂类 也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则： 不闭包可以理解为 ： 使用有条件的，有细节的，通用性要低 从设计角度考虑，有一定的问题，如何解决？ 就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 tips ： 这里把修改转移到了增加 修改对应的是原来的，而增加是扩展的 — &gt; 遵循开闭原则，扩展而不是修改已有的 //1. 接口 public interface Sender { public void Send(); } //2. 接口实现类 1 public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } //2. 接口实现类 2 public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } //3. 工厂接口 public interface Provider { public Sender produce(); } //4. 工厂类 1 public class SendMailFactory implements Provider { ​ @Override public Sender produce(){ return new MailSender(); } } //4. 工厂类 2 public class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } 其实这个模式的好处就是，如果想增加一个功能：发及时信息，则只需 1.创建一个实现类（模块类），实现 Sender 接口 2.创建一个工厂类，实现 Provider 接口 就OK了，无需去改动现成的代码。这样做，拓展性较好！ tips： 扩展性的好坏不是一定的，项目的规模大小也会影响。 假设要增加 100 个模块类，那就要创建 200个类，这种情况下，该设计模式可能就不具有优势了。 单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。 在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。2、省去了 new 操作符，降低了系统内存的使用频率，减轻 GC 压力。3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。 // 方式 1. 简单单例 不适用于多线程 – &gt; 单例两种方式 1. 饿汉式：空间换时间 2. 懒汉式： 时间换空间 延时加载 public class Singleton { /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 静态工程方法，创建实例 */ public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } // 方式 2. 方法同步锁，锁类 ，影响性能 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } // 方式 3. 双重锁机制 ---- &gt; 懒汉式 public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } // 饿汉式 ：直接创建对象 public class Singleton{ private static Singleton singleton = new Singleton (); private Singleton (){} public static Singleton getInstance(){ return singletion; } } 设计模式 4建造者模式（Builder） 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象， 所谓复合对象就是指某个类具有不同的属性。 // 借用以上 Sender 接口及其 2 个实现类 public class Builder { ​ private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new MailSender()); } } public void produceSmsSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new SmsSender()); } } } 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。 所以与工程模式的区别就是： 工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。 因此，是选择工厂模式还是建造者模式，依实际情况而定。 tips ：框架中常见的一种使用场景是链式调用。 原型模式（Prototype）原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出， 该模式的思想就是：将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。 public class Prototype implements Cloneable { // cloneable 是空方法 public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } } 适配器模式适配器模式将某个类的接口转换成客户端期望的另一个接口表示 目的是消除由于接口不匹配所造成的类的兼容性问题。 主要分为 3 类：类的适配器模式、对象的适配器模式、接口的适配器模式。 核心思想就是： 有一个 Source 类，拥有一个方法，待适配 目标接口 Targetable，通过 Adapter 类，将 Source 的功能扩展到 Targetable 里。 类的适配器 // 1.1 public class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } } // 1.2 接口 public interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); } // 1.3 类适配 public class Adapter extends Source implements Targetable { @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } } 对象的适配器模式： 基本思路和类的适配器模式相同： 只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 // 1.3 对象适配 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source){ super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } } 接口适配器 第三种适配器模式是接口的适配器模式，接口的适配器是这样的： 有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的， 有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式 借助于一个抽象类，该抽象类实现了该接口， 实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系， 所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 接口 public interface Sourceable { ​ public void method1(); public void method2(); } 抽象类 public abstract class Wrapper2 implements Sourceable{ ​ public void method1(){} public void method2(){} } 子类1 public class SourceSub1 extends Wrapper2 { // @Override //选择性重写 public void method1(){ System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); } } 子类 2 public class SourceSub2 extends Wrapper2 { //@Override //选择性重写 public void method2(){ System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); } } 3 种适配器模式的应用场景： 类的适配器模式： 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式： 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式： 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 装饰者模式顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下： // 1. 接口 public interface Sourceable { public void method(); } // 2. 被装饰类 public class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } } // 3. 装饰类 public class Decorator implements Sourceable { private Sourceable source; public Decorator(Sourceable source){ super(); this.source = source; } @Override public void method() { System.out.println(&quot;before decorator!&quot;); source.method(); System.out.println(&quot;after decorator!&quot;); } } tips ：好像不要接口也是可以的 不细究了，不过对于被装饰类的方法是私有的或者是不同的人操作的，可能要考虑一些问题了。 装饰器模式的应用场景： 1、需要扩展一个类的功能。2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ 代理模式其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作 e.g.比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。 // 1.接口 public interface Sourceable { public void method(); } // 2. 实现类 public class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } } // 3. 代理类 public class Proxy implements Sourceable { private Source source; public Proxy(){ super(); this.source = new Source(); } @Override public void method() { before(); source.method(); atfer(); } private void before() { System.out.println(&quot;before proxy!&quot;); } private void atfer() { System.out.println(&quot;after proxy!&quot;); } } 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有 2 种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 外观模式（Facade）外观模式是为了解决类与类之间的依赖关系的， 像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口 // cpu public class CPU { ​ public void startup(){ System.out.println(&quot;cpu startup!&quot;); } public void shutdown(){ System.out.println(&quot;cpu shutdown!&quot;); } } // memory public class Memory { ​ public void startup(){ System.out.println(&quot;memory startup!&quot;); } public void shutdown(){ System.out.println(&quot;memory shutdown!&quot;); } } // disk public class Disk { ​ public void startup(){ System.out.println(&quot;disk startup!&quot;); } public void shutdown(){ System.out.println(&quot;disk shutdown!&quot;); } } // 计算机 public class Computer { private CPU cpu; private Memory memory; private Disk disk; public Computer(){ cpu = new CPU(); memory = new Memory(); disk = new Disk(); } public void startup(){ System.out.println(&quot;start the computer!&quot;); cpu.startup(); memory.startup(); disk.startup(); System.out.println(&quot;start computer finished!&quot;); } public void shutdown(){ System.out.println(&quot;begin to close the computer!&quot;); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(&quot;computer closed!&quot;); } } // User 用户 public class User { public static void main(String[] args) { Computer computer = new Computer(); computer.startup(); computer.shutdown(); } } 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！ tips: 这个类之间的耦合也是蛮大 参考资料应该是 JAVA ，13 年的 桥接模式（Bridge）桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。 桥接的用意是： 将抽象化与实现化解耦，使得二者可以独立变化 像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候， 在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动， 原因就是： JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 // 1. 接口： public interface Sourceable { public void method(); } // 2.1 实现类 1 public class SourceSub1 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the first sub!&quot;); } } // 2.2 实现类 2 public class SourceSub2 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the second sub!&quot;); } } // 3. 定义一个桥，持有Sourceable的一个实例： public abstract class Bridge { private Sourceable source; public void method(){ source.method(); } public Sourceable getSource() { return source; } public void setSource(Sourceable source) { this.source = source; } } public class MyBridge extends Bridge { public void method(){ getSource().method(); } } 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。 组合模式（Composite）组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便 public class TreeNode { ​ private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); ... setter getter //添加孩子节点 public void add(TreeNode node){ children.add(node); } //删除孩子节点 public void remove(TreeNode node){ children.remove(node); } //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren(){ return children.elements(); } } public class Tree { TreeNode root = null; public Tree(String name) { root = new TreeNode(name); } public static void main(String[] args) { Tree tree = new Tree(&quot;A&quot;); TreeNode nodeB = new TreeNode(&quot;B&quot;); TreeNode nodeC = new TreeNode(&quot;C&quot;); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(&quot;build the tree finished!&quot;); } } 使用场景： 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 享元模式（Flyweight）享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时， 工厂需要检查当前对象池中是否有符合条件的对象， 1. 如果有，就返回已经存在的对象， 2. 如果没有，则创建一个新对象，FlyWeight是超类。 一提到共享池，我们很容易联想到Java里面的JDBC连接池， 想想每个连接的特点，我们不难总结出： 适用于作共享的一些个对象，他们有一些共有的属性： 就拿数据库连接池来说： url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的， 所以就适合用享元模式来处理： 建一个工厂类，将上述类似属性作为内部数据， 其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 // 数据库连接池的代码： public class ConnectionPool { ​ private Vector&lt;Connection&gt; pool; /*公有属性*/ // ---&gt; public private String url = &quot;jdbc:mysql://localhost:3306/test&quot;; private String username = &quot;root&quot;; private String password = &quot;root&quot;; private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() { pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) { try { Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } } /* 返回连接到连接池 */ public synchronized void release() { pool.add(conn); } /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() { if (pool.size() &gt; 0) { Connection conn = pool.get(0); pool.remove(conn); return conn; } else { return null; } } } 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！ 第一类：通过父类与子类的关系进行实现。 第二类：两个类之间。 第三类：类的状态。 第四类：通过中间类 策略模式（strategy）策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。 图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类： // 1. 统一接口： public interface ICalculator { public int calculate(String exp); } // 2. 辅助类： public abstract class AbstractCalculator { ​ public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } // 实现类 1 public class Plus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\+&quot;); return arrayInt[0]+arrayInt[1]; } } // 实现类 2 public class Minus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;-&quot;); return arrayInt[0]-arrayInt[1]; } } // 实现类 3 public class Multiply extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\*&quot;); return arrayInt[0]*arrayInt[1]; } } 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 模板方法模式（Template Method）模板方法模式： 1. 1 个抽象类中，有 1 个主方法，n 个抽象的或实际的方法 2. 继承抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用 就是在 AbstractCalculator 类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用 public abstract class AbstractCalculator { ​ /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt){ int array[] = split(exp,opt); return calculate(array[0],array[1]); } /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } public class Plus extends AbstractCalculator { @Override public int calculate(int num1,int num2) { return num1 + num2; } } 我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。 观察者模式（Observer）包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。 观察者模式很好理解： 类似于邮件订阅和RSS订阅， 当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章， 如果后续有更新，会及时通知你。 简单来讲： 当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 这些类的作用： MySubject类就是我们的主对象， Observer1和Observer2是依赖于MySubject的对象， 当MySubject变化时，Observer1和Observer2必然变化。 AbstractSubject类中定义着需要监控的对象列表， 可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象 // 一个Observer接口： public interface Observer { public void update(); } // 实现类1 public class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } } // 实现类2 public class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } } //Subject接口及实现类： public interface Subject { ​ /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); } public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } 这些东西有些抽象，不太容易整体理解， 建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）, 按照总体思路走一遍，这样才能体会它的思想，理解起来容易！ 迭代子模式（Iterator）顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见， 如果对集合类比较熟悉的话，理解本模式会十分轻松。 这句话包含两层意思： 一是需要遍历的对象，即聚集对象 二是迭代器对象，用于对聚集对象进行遍历访问。 这个思路和我们常用的一模一样： MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例 //接口 1 public interface Collection { ​ public Iterator iterator(); /*取得集合元素*/ public Object get(int i); /*取得集合大小*/ public int size(); } // 接口 2 public interface Iterator { //前移 public Object previous(); //后移 public Object next(); public boolean hasNext(); //取得第一个元素 public Object first(); } // 实现 1 public class MyCollection implements Collection { public String string[] = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; @Override public Iterator iterator() { return new MyIterator(this); } @Override public Object get(int i) { return string[i]; } @Override public int size() { return string.length; } } // 实现 2 public class MyIterator implements Iterator { private Collection collection; private int pos = -1; public MyIterator(Collection collection){ this.collection = collection; } @Override public Object previous() { if(pos &gt; 0){ pos--; } return collection.get(pos); } @Override public Object next() { if(pos&lt;collection.size()-1){ pos++; } return collection.get(pos); } @Override public boolean hasNext() { if(pos&lt;collection.size()-1){ return true; }else{ return false; } } @Override public Object first() { pos = 0; return collection.get(pos); } } 此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？ 其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！ 责任链模式（Chain of Responsibility）责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求， 所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。 Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。 public interface Handler { public void operator(); } public abstract class AbstractHandler { ​ private Handler handler; public Handler getHandler() { return handler; } public void setHandler(Handler handler) { this.handler = handler; } } public class MyHandler extends AbstractHandler implements Handler { private String name; public MyHandler(String name) { this.name = name; } @Override public void operator() { System.out.println(name+&quot;deal!&quot;); if(getHandler()!=null){ getHandler().operator(); } } } 此处强调一点就是： 链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。 命令模式（Command）命令模式的理解： 举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。 Invoker是调用者（司令员）Receiver是被调用者（士兵）MyCommand是命令，实现了Command接口，持有接收对象 public interface Command { public void exe(); } public class MyCommand implements Command { private Receiver receiver; public MyCommand(Receiver receiver) { this.receiver = receiver; } @Override public void exe() { receiver.action(); } } public class Receiver { public void action(){ System.out.println(&quot;command received!&quot;); } } public class Invoker { ​ private Command command; public Invoker(Command command) { this.command = command; } public void action(){ command.exe(); } } public class Test { public static void main(String[] args) { Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); } } 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开， Struts中：Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。 第三类和第四类。备忘录模式（Memento）主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象， 叫备份模式更形象些 通俗的讲下： 假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。 Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。 public class Original { ​ private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Original(String value) { this.value = value; } public Memento createMemento(){ return new Memento(value); } public void restoreMemento(Memento memento){ this.value = memento.getValue(); } } public class Memento { ​ private String value; public Memento(String value) { this.value = value; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class Storage { ​ private Memento memento; public Storage(Memento memento) { this.memento = memento; } public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } 简单描述下： 新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。 状态模式（State）核心思想就是： 当对象的状态改变时，同时改变其行为，很好理解！ 就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态， 所以，状态模式就两点： 1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。 // State类是个状态类，Context类可以实现切换 public class State { ​ private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public void method1(){ System.out.println(&quot;execute the first opt!&quot;); } public void method2(){ System.out.println(&quot;execute the second opt!&quot;); } } public class Context { private State state; public Context(State state) { this.state = state; } public State getState() { return state; } public void setState(State state) { this.state = state; } public void method() { if (state.getValue().equals(&quot;state1&quot;)) { state.method1(); } else if (state.getValue().equals(&quot;state2&quot;)) { state.method2(); } } } 根据这个特性，状态模式在日常开发中用的挺多的， 尤其是做网站的时候，我们有时希望根据对象的某一属性， 区别开他们的一些功能，比如说简单的权限控制等。 访问者模式（Visitor）访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。 访问者模式适用于： 数据结构相对稳定算法又易变化的系统。 因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。 访问者模式的优点： 是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。 其缺点是： 增加新的数据结构很困难。 简单来说: 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离， 可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 // 一个Visitor类，存放要访问的对象， public interface Visitor { public void visit(Subject sub); } public class MyVisitor implements Visitor { @Override public void visit(Subject sub) { System.out.println(&quot;visit the subject：&quot;+sub.getSubject()); } } // Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性， public interface Subject { public void accept(Visitor visitor); public String getSubject(); } public class MySubject implements Subject { @Override public void accept(Visitor visitor) { visitor.visit(this); } @Override public String getSubject() { return &quot;love&quot;; } } 该模式适用场景： 如果我们想为一个现有的类增加新功能，不得不考虑几个事情： 1、新功能会不会与现有功能出现兼容性问题？ 2、以后会不会再需要添加？ 3、如果类不允许修改代码怎么办？ 面对这些问题，最好的解决方法就是: 使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦 中介者模式（Mediator）中介者模式也是用来降低类类之间的耦合的： 因为如果类类之间有依赖关系的话， 不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。 如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行， 这有点像spring容器的作用。 User类统一接口，User1和User2分别是不同的对象，二者之间有关联 如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高， 为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类， 里面持有User1和User2的实例，用来实现对User1和User2的控制。 这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行， 剩下的全由MyMediator类来维护！基本实现： public interface Mediator { public void createMediator(); public void workAll(); } public class MyMediator implements Mediator { private User user1; private User user2; public User getUser1() { return user1; } public User getUser2() { return user2; } @Override public void createMediator() { user1 = new User1(this); user2 = new User2(this); } @Override public void workAll() { user1.work(); user2.work(); } } public abstract class User { ​ private Mediator mediator; public Mediator getMediator(){ return mediator; } public User(Mediator mediator) { this.mediator = mediator; } public abstract void work(); } public class User1 extends User { public User1(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user1 exe!&quot;); } } public class User2 extends User { public User2(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user2 exe!&quot;); } } 解释器模式（Interpreter）一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 //Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现 public interface Expression { public int interpret(Context context); } public class Plus implements Expression { @Override public int interpret(Context context) { return context.getNum1()+context.getNum2(); } } public class Minus implements Expression { @Override public int interpret(Context context) { return context.getNum1()-context.getNum2(); } } public class Context { ​ private int num1; private int num2; public Context(int num1, int num2) { this.num1 = num1; this.num2 = num2; } public int getNum1() { return num1; } public void setNum1(int num1) { this.num1 = num1; } public int getNum2() { return num2; } public void setNum2(int num2) { this.num2 = num2; } } 基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[版权声明]]></title>
      <url>%2F2017%2F04%2F22%2F%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%2F</url>
      <content type="text"><![CDATA[创建该博客网站是受 stormzhang 的影响，写博客的初衷也是以学习、记录、交流为主，若网站博客中有侵权、未注明明显出处等情况发生，请用邮箱联系我。 对于博客中涉及类似侵权、未在明显位置注明出处等行为，请原创作者原谅，这非博主本意，可能参照的东西太多未细分或者疏忽导致。 另外，本站博客可任意转载，不必获取授权或者带有转载等字眼。但若发生被转载的文章是本站博客中的非原创作品，而转载者又未声明版权所有者等类似情况的，请转载者自行负责。 本版权声明长期有效，未尽事宜，请用邮箱联系我，Email：m8538343069@foxmail.com。 04/22/2017 Jan9th]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo NexT 使用中的小细节]]></title>
      <url>%2F2017%2F04%2F22%2FHexo-NexT-%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[Hexo NexT 应用中的小技巧，使用过程中不定期更新。 中文模式 站点：language: zh-Hans 更新生效 主题配置和文章，修改后刷新浏览器可以直接生效；站点配置更改需要重新生成才能生效。 本地搜索 安装 hexo-generator-searchdb 插件，执行 npm install hexo-generator-searchdb --save 增加站点配置，如下：&gt; search: path: search.xml field: post format: html limit: 10000 创建分类 创建分类页 hexo new page categories 分类页 index.md 增加 type: &quot;categories&quot; 实现分类跳转 创建 tag 页 创建 tag 页 hexo new page tags tag 页 index.md 增加 type: &quot;tags&quot; 实现 tag 跳转 more 字段 使用 NexT 主题可以在文章中增加 &lt;!--more--&gt; ，more 字段上的为摘要。 修改模版 scaffolds 文件夹中 post.md page.md draft.md 文件为模版文件 --#- title: {{ title }} categories: tags: comments: false --#- &lt;!#--more--&gt; 去掉所有的 # 成为自定义模版文件 多 tag tag: [Hexo,NexT] 英文符号，中间有个空格。 创建草稿 hexo new draft Hello 在 source/-drafts 下生成 Hello.md 文件 默认不预览，网站配置 render_drafts 节点更改渲染/预览。 或使用 hexo server --drafts 开启临时预览。 发布草稿 hexo publish Hello 多个分类 同一篇文章不支持两个分类字数统计 更改 \themes\next\ _config.yml 中 busuanzi_count 节点 执行npm install hexo-wordcount --save 插件名后加 @2.0.1 指定版本 打赏禁止动画 next/source/css/_common/components/post/post-reward.styl 中注释 alipay 和 wechart 动画 内链颜色 themes\next\source\css\_common\components\post\post.styl 中自定义样式&gt; .post-body p a{color: #0593d3; border-bottom: none; &amp;:hover { color: #0477ab; text-decoration: underline; } } 查看版本 使用 hexo -v 卸载 npm uninstall hexo-cli -g # 未实践过npm remove hexo-generator-searchdb 置顶 使用 npm install --save hexo-generator-index 插件，多个置顶按等级和时间顺序。 更改 ../node_modules/hexo-generator-index/lib/generator.js 文件 文章中增加 top: true 配置 版权所有者：Netcan_Space :解决 Hexo 置顶问题 ico 转换 在线制作工具 网站标签页 Hexo系列教程之三：next主题的配置和优化 站点收录 $ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-generator-sitemap --save 网站配置中增加节点 sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 生成，预览$ hexo g$ hexo s如果不生效就先执行$ hexo clean 版权所有者：svendHexo系列：(四)Hexo博客提交百度和Google收录 远程仓库更改 仓库地址查看 git remote -v 更换仓库 git remote set-url origin &lt;repo&gt; 本地仓库改名 git remote rename [current name] [new name] 移除本地仓库名 git remote rm origin 此操作所有 origin 均会被移除 错误警告 warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX.的警告。git config --global core.autocrlf false unix/Linux/mac/windows 不同系统对应回车、换行的定义不一样，Git 存储时，有针对于 不同平台间的转换，是某种操作导致了这种转换被开启，与二进制存储时是否可逆有关系，具体的不是十分明白。 全面教程格子林ll 简书]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[About Hexo]]></title>
      <url>%2F2017%2F04%2F22%2FAbout-Hexo%2F</url>
      <content type="text"><![CDATA[Quick Start Welcome to Hexo ! Check documentation for more info. Any problems when using Hexo, find the answer in troubleshooting or on GitHub. Create a new post1$ hexo new "New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F19%2F%E5%9F%BA%E4%BA%8E-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[摘要 博客由 GitHub 托管，采用 GitHub Pager 静态网页 + Hexo 博客框架 + NexT 主题，本文介绍了博客搭建的关键步骤。 工具安装安装 Node.js 自定义安装路径，其余默认配置，一路 next 。 安装 Git 工具 自定义安装路径，其余默认配置，一路 next 。 使用 Git 工具安装 Hexo 鼠标右键 Git GUI 选择 Git Bash Here 执行 ： $ npm install hexo-cli -g 构建 Hexo 、Node.js 等初始化环境，$ 是自动生成的。 GitHub 认证配置 username 和 email$ git config --global user.name &quot;username&quot; # 设置用户名 $ git config --global user.email &quot;me@email.com&quot; # 设置邮箱 $ git config --global user.name # 查看用户名 $ git config --global user.email # 查看邮箱 用户名和邮箱是任意的，影响不大。 生成认证指纹$ ls ~/.ssh # 检查认证指纹 ssh key 设置，不区分大小。 $ ssh-keygen -t rsa -C &quot;me@email.com&quot; # C 为大写字母，其后为邮箱 输入 ssh key 保存位置，输入并确认密码，均可以直接回车默认。 $ ls ~/.ssh # 检查 ssh key $ cat ~/.ssh/id_rsa.pub # 抓取配置中的 ssh key，可以先复制下来。 email 是用于生成 ssh key，可以是其他的，也可以理解为生成 ssh key 的一个关键字。 添加 ssh key GitHub 账号的 Personal settings 下 SSH and keys 中添加生成的 ssh key 。 创建仓库 GitHubName：GitHubName.github.io # GitHubName 为 GitHub 用户名，这是约定好的。 创建连接$ ssh -T git@github.com # T 不能为小写 测试本机与 GitHub 之间的 ssh key 连接/是否有效（或是否可以连接） 若第一次配置，最后出现 Are you sure ...（yes/no）? 字样，键入 yes 确认。 若配置过，会直接显示配置的用户名。 快速启动初始化$ hexo init X:\Blog # 在硬盘 X 分区，自定义 Blog 文件夹中初始化。 生成网页$ hexo g # hexo generate 生成静态网页 启动服务$ hexo s # hexo server 启动本地预览服务 本机 localhost:4000 或 http://localhost:4000 可以查看效果，https://localhost:4000 https 协议无法通过。 拉取仓库$ git clone &lt;repo&gt; .deploy/xxx 或者 $ git clone &lt;repo&gt; .deploy/xxx 若直接下载解压，没有 .git 忽略文件，可以尝试 git init 指令，效果未知。 repo 是仓库地址 .deploy 和 xxx 是文件夹 创建脚本脚本 1hexo clean # 命名为 .sh 文件 hexo g 可用于清除旧主题，生成新网页。 脚本 2hexo g # 推荐命名为 deploy.sh。 cp -R public/* .deploy/xxx cd .deploy/xxx # 与上述一致 git add . # add 后面有空格和点 git commit -m &quot;update&quot; # master git push origin master # 推送服务器 使用: 先使用脚本 1 用于清除缓存和静态网页，再使用脚本 2 用于向服务器仓库推送。 脚本可自行搭配，注意扩展名，并放到之前初始化过的 X:\Blog 根目录。脚本 3 cd X：/Blog # 切换到网站根目录 hexo clean # 清除 hexo g # 生成 cp -R public/* .deploy/xxx # copy cd .deploy/xxx # 切换目录 git add . # add git commit -m “update” # 提交信息 git push origin master # 推送 更改 X 和 Blog 对应到安装路径根目录 文章创建创建新文件 $ hexo new Hello 生成网页$ hexo g 更换主题 每次更换主题前需要更改网站配置文件 _config.yml 中 themes 节点对应的本地已有的主题名，Blog 安装目录/子目录下执行 $ hexo clean 清除旧主题,再执行静态网页生成 $ hexo g 、本地预览 $ hexo s、部署 $ hexo d 步骤。 themes 文件夹为主题相关的配置，根目录为网站相关的配置。 远程仓库初始化本地$ hexo init 拉取到本地$ git clone remoteRepoAdress # &quot;remoteRepoAdress&quot; 是远程仓库地址 添加多个远程仓库 git remote add origin remoteRepoAdress # 目前操作还有问题，待解决。 git remote set-url origin remoteRepoAdress # 改变 repo，但改变后的后续实现还有问题。 git remote # 查看远程仓库，返回结果一般为 “orgin” 。 git remote -v # 查看远程仓库地址，返回结果为：$ origin remoteRepoAdress (fetch) $ origin remoteRepoAdress (push) 在实践过程中，还有问题没有搞好，找到一个解决方案。 常用指令 $ git clone repo target repo 仓库地址，target 目标地址（本地文件夹）。 $ hexo g 生成部署文件 $ hexo s 开启本地预览服务 ctrl + c 停止本地预览服务 $ hexo d 推送到远程仓库 $ cd x 切换到 x 文件夹，非直接子目录无法切换。 $ cd x: 切换到 x: 分区，任意切换。 $ cd .. 回到上层目录 $ ls 列出所有文件和文件夹 $ ls *.md 列出所有扩展名为 .md 的文件 $ git status 查看当前状态 $ git -a == $ git add 切换 上 下键，切换历史键入记录，与 dos 不同的是：即使是不同的窗口或者窗口关闭过也是可以记录的。 更改主题或主题配置的执行顺序是： 更改根目录 _config.yml 文件 themes 节点 –&gt; $ hexo clean –&gt; $ hexo g –&gt; $ hexo s –&gt; $ hexo d。 本地预览和向服务器推送时，会有延时，多等待一会儿或多刷新几次就可以看到效果了。 常见问题 SSH 认证【英】 公钥【英】 参考及收藏 基于Hexo+GitHub Pages 搭建个人博客教程 基于Hexo-Github—搭建个人博客笔记 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 xuhao 珞神 IIssNan 网站 Node Git Pro Git(中文版) Git 常用操作命令 Git 参考手册 Hexo GitHub Hexo Docs Hexo wiki GitHub Next 主题 Next 配置 博客改造 使用Hexo基于GitHub Pages搭建个人博客 浚宇的博客 浚宇的博客 issue custome logo 底部统计图标 段间距 Blog 秀 本地预览 4000 端口]]></content>
    </entry>

    
  
  
</search>
