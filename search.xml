<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JNI/NDK]]></title>
      <url>%2F2017%2F05%2F24%2FJNI-NDK%2F</url>
      <content type="text"><![CDATA[JNI/NDK 学习记录 深入理解 Android 卷IJNI/NDK 开发指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava 学习]]></title>
      <url>%2F2017%2F05%2F21%2FRxJava-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[个人收藏学习 RxJava // 引用图片语法 {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} // 实例 {% asset_path 01.png %} {% asset_img 01.png 图片 %} {% asset_link 01.png 图片 %} 原文：RxJava资源合集－学习RxJava,看这里就够了 /2017/05/21/RxJava-学习/01.png A Complete Guide To Learn RxJava 第一部分什么是 RxJava ? RxJava 是响应式程序设计的一种实现。在响应式程序设计中，当数据到达的时候，消费者做出响应。响应式编程可以将事件传递给注册了的 observer。 RxJava是对于Android项目来说是一个重要的library 那么什么是命令行式编程呢？ Grokking RxJava 系列通过例子学习RxJava（Learn RxJava By Examples）通过例子学习是最佳的学习方式。它包含许多例子，如： 如何使用操作符？ 如何做网络调用？ 如何实现RxBus(EventBus)? 如何使用RxJava实现pagination？ 另一个学习RxJava的例子是Kaushik的RxJava-Android-Samples Jake Wharton 视频探索RxJava 2 使用RxJava管理状态(Managing State with RxJava by Jake Wharton) 另一个通过例子学习 RxJava 的视频 视频地址 理解 RxJava Subject — Publish, Replay, Behavior 以及 Async Subject在网络中使用 RxJava（Using RxJava In Networking）link Better Explanation of RxJava and Using It In Androidlink 响应式编程全面介绍Link here. RxJava 介绍Link here. Crunching RxAndroid为什么要在 Android 中使用 RxJava?第二部分给 Android 开发者的 RxJava 详解 RxJava 与 Retrofit 结合的最佳实践 第三部分 理解和整理 RxJava 中有 backpressure 概念，在 RxJava 1 后期版本中默认都扩展了，但并不是所有的资源都有这个需要。backpressure 继承时必须处理，是处在事件的最前面，必须要处理。在 RxJava 2 中将这种情况分开来处理了，分为两种类型 Observable 和 Flowable ，前者没有背压，后者有背压 触摸事件采用的是无背压的 observable，发射事件是可以不受阻塞/或者不减速的得到响应的。可控制的用背压形式的 flowable ，是交互式的，根据需求去拉取。 通过一定的策略可以将两种类型相互装换，但开发者并不打算这样去设计（Jake Wharton ）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[待整理]]></title>
      <url>%2F2017%2F05%2F21%2F%E5%BE%85%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[待整理归类的临时收藏 泡在网上的日子 使用 Hexo 与 NexT 搭建博客的避坑总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin 记录]]></title>
      <url>%2F2017%2F05%2F20%2Fkotlin-%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[记录 fun main(args: Arrary&lt;String&gt;){// 入口 main 方法，变量 args ，String 泛型数组 args.map({println(it)}) // lambda 表达式 args.map(){println(it)}/args.map{println(it)} // args.map(::method) lambda 方法表达式中调用 method 方法 } main 方法 入口 fun 方法声明 var 变量 val 常量 Arrary&lt;out String&gt; String 类型的数组，out 为 输出 ，因为 String 为 final 所以，out 可省略 没有 new / 对象不用 new data class ClassName(){} JavaBean,自动重写了 setter getter toString hashCode 等 map 映射，属于一个扩展方法 没有/可以省略分号 flatmap 迭代的映射，属于一个组迭代的扩展方法 var name :String 变量声明为 String ? 定义允许为空 $ 字符串模版 args it 迭代器 运行后配置参数 program args --&gt; 编译时反射 Unit void 返回类型，可以省略 .kt kt 语言 enum class ClassName｛｝// 枚举类 有 class 修饰，与 Java 不同 fun main(varagr arg:String){ //kt 语言 main 方法 } comparion object ｛｝ // kotlin 伴生对象 Java 静态方法/静态变量/静态常量 init{} // 主构造方法 fun ClassName.hello(){} // ClassName 类的扩展方法 hello ,是原类中没有的，以 类名. 连缀方法名即类的扩展方法 when(this) 类似于 switch（xxx），但是有返回值 尾递归 ：只有递，没有归回来 常规会迭代，开占内存， tailrec 编译时进行尾递归优化 递归 ：递过去，又归来]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[资料整理]]></title>
      <url>%2F2017%2F05%2F16%2F%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[初步整理，多维度的学习资料，后期会陆续加上链接。 视频学习： 红树林教育 Steven 教你学 Android 黑马程序员 慕课网 极客学院 麦子学院 技术博客 CodeKK 开源项目源码解析及优秀开源项目分享 Trinea 性能优化、源码解析 老罗的 Android 之旅 Android 系统源代码分析 开发技术前线 Mr.Simple 维护的社区网站 CSDN 博客专家 夏安明 兰亭风雨 赵凯强 qinjuning 工匠若水 张兴业 任玉刚 《Android开发艺术探索》 郭霖 《第一行代码》 鸿洋 Coder-pig 最佳入门专栏 全速前行 主讲实战技巧和平常遇到的问题 郑海波 文章大多与自定义控件相关 著名博主 胡凯 —— 专注性能优化 张明云 —— Android 学习之路 Drakeet —— 贝壳单词 APP 开发者 徐宜生 —— 《Android群英传》作者 代码家 —— 著名博主 脉脉不得语 —— 著名博主 高建武 —— 专注性能优化，简书著名博主 程序亦非猿—— 简书著名博主 廖祜秋liaohuqiu_秋百万 —— 淘宝职员 hi大头鬼hi —— 对RxJava有较深的研究 阳春面 —— 简书著名博主 开发技术前线 —— 《Android源码设计模式》作者 Mr.Simple 维护的社区网站 爱哥 ——《Android源码设计模式》关爱民 Keegan小刚 —— 分享了多篇 Android 样式的文章 吴小龙同学 —— 分享了多篇关于 AndroidDesignSupportLibrary 的文章 社区 Stackoverflow V2ex V2ex Android 板块 Android 开发技术周报 长期更新最新前言资讯 开发技术前线 Mr.Simple 维护的社区网站 泡在网上的日子 大量第三方控件基地 23code android 经典开源代码分享 App 开发者 分享 Android/IOS/Swift 开发和互联网内容 JavaApk.com 安卓 demo 聚集地，部分源码需 VIP DevStore 各种 Demo，以及第三方服务 开源中国 书籍 第一行代码 Android 群英传 Android 疯狂讲义 Android 源码设计模式解析与实战 何红辉(Simple哥)，关爱民(爱哥)两人，设计模式，设计思想 Android 开发艺术探索 任玉刚，侧重于 Android 知识的体系化和系统工作机制的分析 深入解析 Android 5.0 系统 剖析 Android 5.0 系统主要框架的原理和具体实现 wiki Android Developer Android Training Material Design Android Weekly 极客学院 项目 代码下载 Github AndroidBus eoeAndroid ITEye 51CTO Android 开源项目分类汇总 通用流行框架 缓存 DiskLruCache 图片加载 Android-University-ImageLoder Picasso Fresco Glide 图片处理 Picasso-transformations Glide-transformations Android-gpuimage 网络请求 Android Async Http AndroidAsync OKhttp Retrofit Volley 网络解析 Json解析 Gson Fastjson Jackson HTML解析 HtmlPaser Jsoup 数据库 OrmLite Sugar GreenDao ActiveAndroid SQLBirte Reaim 依赖注入 ButterKnife 8.0 有Bug 必须在 Gulide 添加代码 Dagger2 AndroidAnotations RoboGuice 图表 HelloCharts WillamChart MPAndroidChart 后台处理 Tape Android Priority job Queue 事件总线 EventBus Otto 响应式编程 RxJava 搭建架构 架构设计 MVP模式 MVC模式 clean模式 MVVM模式 常用框架 网络请求 OKHttp + Retrofit + RxJava (向 Java 8 以下兼容的 Retrolambda) 图片加载 Clide Fresco picasso 几种框架比较 存储 数据库ORM框架 greenDao NoSql realm-java 消息总线 RxBus EvenBus 依赖注入 ButterKnife Dagger2 简单例子 子线程和主线程的切换 RxJava 到底是什么? 异步 一个在 JavaVM 上使用可观测的序列来组成异步,基于事件程序的库 RxJava 好在哪里? 简洁 RaJavaJoins RxAndroid 使用 // Just public void ObserveableJust() { Observable.just(0, 1, 2).subscribe(new Action1&lt;Integer&gt;() { //call方法根据里面的参数依次发送出去 总共调用了三次 @Override public void call(Integer integer) { Log.e(TAG, &quot;call&quot; + integer); //result == 0 1 2 } }); } // Range public void ObserveRange() { Observable.range(0, 10).subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { Log.e(TAG, &quot;call:&quot; + integer); //result == 0 1 2 3 4 5 6 7 8 9 } }); } // Repeate public void ObserveableRepeat() { Observable.just(0, 1).repeat(5).subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer integer) { Log.e(TAG, &quot;call:&quot; + integer); //result == 0 1 ,0 1 ,0 1, 0 1, 0 1 } }); } RxBinding Log框架 Logger Hugo Timber 测试框架 Mockito Robotium Robolerctric 适配框架 性能优化 内存泄漏检测 LeakCanary 崩溃报告 ACRA 调试框架 Stetho]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android LayoutInflater]]></title>
      <url>%2F2017%2F05%2F14%2FAndroid-LayoutInflater%2F</url>
      <content type="text"><![CDATA[布局加载 常规方法加载内容布局 //包裹 activity 对应的 FrameLayout 父布局，原内容布局根节点下 layout 属性生效 setContentView(R.layout.activity_main) 或者 LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); 布局加载器加载布局 //获取布局加载器 LayoutInflater layoutInflater = LayoutInflater.from(context); //加载布局 resourceId：布局 id，root 指定父布局 容器布局调 //用 addView 添加子布局 layoutInflater.inflate(resourceId, root); //root != null 并且 boolean 值为 true 时，被加载的布局的layout属性会生效 layoutInflater.inflate(resourceId, root,boolean); 布局加载器动态加载 Demo： 布局容器 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/main_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;/LinearLayout&gt; item 布局 &lt;Button xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; &gt; &lt;/Button&gt; 动态加载布局 public class MainActivity extends Activity { private LinearLayout mainLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainLayout = (LinearLayout) findViewById(R.id.main_layout); LayoutInflater layoutInflater = LayoutInflater.from(this); View buttonLayout = layoutInflater.inflate(R.layout.button_layout, null); mainLayout.addView(buttonLayout); } } guolin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[他山之石]]></title>
      <url>%2F2017%2F05%2F14%2F%E4%BB%96%E5%B1%B1%E4%B9%8B%E7%9F%B3%2F</url>
      <content type="text"><![CDATA[博主链接，文章链接。 Google developerandroid nougatMaterial Design csdn 博主 Hongyang csdn 文章 唯鹿: 一些你需要知道的布局优化技巧 唯鹿: 开源许可协议 掘金 简书 GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 6.0 新特性]]></title>
      <url>%2F2017%2F05%2F14%2FAndroid-6-0-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[初步整理 Android 6.0 新控件 参考 tianzhu2725 TextInputLayout高级炫酷带有提示的输入框，相当于输入框中的战斗框使用需要依赖 design 类库： compile &apos;com.android.support:design:23.0.0+&apos; 使用步骤： 先在 TextInputLayout 中包裹一个 EditText,然后给 EditText 添加文本变化监听器： editText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { } @Override public void afterTextChanged(Editable s) { if(s.length() &gt; 5){ //设置错误提示信息 inputLayout.setError(&quot;不能超过5个&quot;); //启用错误提示 inputLayout.setErrorEnabled(true); }else{ //关闭错误提示 inputLayout.setErrorEnabled(false); } } }); FloatingActionButton总是能悬浮在界面上的 Button，可以设置点击事件使用需要依赖 design 类库： compile &apos;com.android.support:design:23.0.0+&apos; 可以设置以下属性： app:fabSize=&quot;normal&quot;//2个取值，normal=56dp,mini=48dp app:elevation=&quot;10dp&quot;//高度 app:rippleColor=&quot;#0000ff&quot;//按下水波纹颜色 app:pressedTranslationZ=&quot;20dp&quot;//按下Z轴移动距离 注意：设置 android:clickable=&quot;true&quot; 才有按下的效果 Snackbar一个介于 Toast 和 Dialog 之间的和用户交互的控件，显示在界面底部，并且可以设置点击行为，也可以滑动出去在和 FloatingActionButton 一起使用时，需要让 CoordinatorLayout 作为父布局才能使FloatingActionButton 给 SnackBar 腾出空间 TabLayout相当于 ViewPagerIndicator 的指示器效果，一般用来跟 ViewPager 结合使用使用需要依赖design类库： compile &apos;com.android.support:design:23.0.0+&apos; 单独使用 TabLayout 的步骤：先添加 Tab，使用 tabLayout.newTab()方法创建 Tab： //1.添加Tab tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab1&quot;)); 给 tabLayout 设置 tab 改变的监听器： //2.给 tabLayout 添加 tab 改变的监听器 tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() { @Override public void onTabSelected(TabLayout.Tab tab) { Log.e(&quot;TAG&quot;, &quot;onTabSelected: &quot;+tab.getText()); } @Override public void onTabUnselected(TabLayout.Tab tab) { } @Override public void onTabReselected(TabLayout.Tab tab) { } }); 在 xml 中给 TabLayout 设置属性： app:tabIndicatorColor=&quot;#00f&quot;//横线颜色 app:tabSelectedTextColor=&quot;#f00&quot;//选中字体颜色 app:tabTextColor=&quot;#0f0&quot;//默认字体颜色 app:tabMode=&quot;fixed&quot;//fixed：不能滑动，每个Tab平分宽度，scrollable:可以滑动tab，每个tab宽度很小，适用于tab很多的情景 app:tabGravity=&quot;fill&quot;//fill:平分宽度，center:让tab居中,如果tabMode是scrollable，那tabGravity会被忽略 和 ViewPager 关联使用步骤： 先给 ViewPager 填充数据，然后关联 TabLayout 和 ViewPager： //给ViewPager填充数据 viewpager.setAdapter(new MyAdapter()); //关联TabLayout和ViewPager tabLayout.setupWithViewPager(viewpager); 需要注意的是，ViewPager 的 adapter 的 getPageTitle() 方法的返回值将会设置给 Tab 的标题 CoordinatorLayout协调布局，能够协调多个布局的位置关系，可以实现让 FAB 上下滑动，展开或折叠 ToolBar，控制View 扩展收缩以及放大缩小 使用需要依赖 design 类库： compile &apos;com.android.support:design:23.0.0+&apos; 使用它结合 AppBarLayout 实现向上滑动隐藏 ToolBar 的效果： AppBarLayout 会将包裹的所有子 View 作为一个整体的 AppBar，有着统一的界面着色;app:layout_scrollFlags 属性介绍：scroll:表示该 View 可以被滑动出 CoordinatorLayout 的范围，所有想滚动出屏幕的 view 都需要设置这个 flag， 没有设置这个 flag 的 view 将被固定在屏幕顶部。例如，TabLayout 没有设置这个值，将会停留在屏幕顶部 enterAlways:表示任意向下的滚动都会导致该 View 可见exitUntilCollapsed:滚动退出屏幕，最后折叠在顶端enterAlwaysCollapsed:当你的视图已经设置 minHeight 属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度 给想滑动出范围的 View 设置属性，比如 ToolBar： app:layout_scrollFlags=”scroll|enterAlways 给发出滑动行为的View设置属性，比如 ViewPager： app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 实现步骤： 1.CoordinatorLayout 作根控件，包裹 AppBarLayout 和可滚动的控件，比如 ViewPager2.AppBarLayout 包裹 ToolBar 及TabLayout， ToolBar 要滑动，给其设置 app:layout_scrollFlags3.ViewPager 是发出滑动行为的控件，设置属性 app:layout_behavior注意：带 layout_scrollFlags 的 view 需要放在固定 View 的前面，这样滑动的 view 才能够正常退出，而固定的 view 继续留在顶部]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 5.0 新特性]]></title>
      <url>%2F2017%2F05%2F14%2FAndroid-5-0-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[初步整理 5.0 新特性 参考 tianzhu2725 Material Design概念：融合卡片式，立体式的设计风格，强调层次感，动画，阴影等元素。 官网介绍 ToolBar它用来代替 ActionBar，但是比 ActionBar 更加灵活，相当于可以写在布局文件中的 ActionBar；与 DrawerLayout 使用的时候，DrawerLayout 可以覆盖在 ToolBar 上，并且 ToolBar 和ActionBar 不能同时使用 使用 ToolBar 的步骤： 先隐藏 ActionBar，可以继承一个不带 ActionBar 的 Theme，如: style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot; 然后在 Activity 中设置 ToolBar 替代 ActionBar： setSupportActionBar(toolBar); 最后设置 ToolBar 的显示内容： toolBar.setTitle(&quot;ToolBar&quot;);//设置标题 toolBar.setNavigationIcon(iconRes);//设置图标 toolBar.setOnMenuItemClickListener();//设置 Menu Item 点击 动态替换ThemeMaterialTheme 配色方案 让 Activity 使用自定义的 Theme，修改状态栏，ActionBar，界面背景，NavigationBar的颜色。 &lt;style name=&quot;AppTheme&quot; parent=&quot;@android:style/Theme.Material&quot;&gt; &lt;!--状态栏颜色--&gt; &lt;item name=&quot;android:colorPrimaryDark&quot;&gt;#f00&lt;/item&gt; &lt;!--ActionBar 颜色--&gt; &lt;item name=&quot;android:colorPrimary&quot;&gt;#ff0&lt;/item&gt; &lt;!--界面背景颜色--&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorWindowBackground&lt;/item&gt; &lt;!--导航栏颜色--&gt; &lt;item name=&quot;android:navigationBarColor&quot;&gt;#00f&lt;/item&gt; &lt;/style&gt; 动态替换 Theme 的步骤： 定义至少 2 套 theme调用 setTheme 方法设置当前的 theme，但是该方法要在 setContentView 之前，如: setTheme(mTheme); setContentView(R.layout.activity_main); 设置了 Theme，需要 finish 当前 Activity，然后重启当前 Activity，让 Theme 生效 Intent intent = getActivity().getIntent(); getActivity().finish();//结束当前的Activity getActivity().overridePendingTransition(0,0);//不要动画 startActivity(intent); RecyclerView官网 先添加依赖 compile &apos;com.android.support:recyclerview-v7:23.1.1&apos; 设置 LayoutManager：控制 RecyclerView 如何显示布局,系统提供 3 个布局管理器： LinearLayoutManager：线性布局，有横向和竖直方向显示GridLayoutManager：网格布局，有横向和竖直方向显示StaggeredGridLayoutManager： 瀑布流布局，有横向和竖直方向显示 然后给 RecyclerView 设置 Adapter 设置点击事件，由于 RecyclerView 没有 setOnItemClickListener，只能在 Adapter 中给 View 设置 Click 事件 水波纹动画，自定义水波纹动画以及状态选择器动画首先，在Android 5.0 以上，点击效果默认自带水波纹效果，并且有 2 种选择： //矩形边框水波纹 android:background=&quot;?android:attr/selectableItemBackground&quot; //无边框限制水波纹 android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot; 自定义水波纹动画 使用 ViewAnimationUtils 创建圆形水波纹动画，注意该动画不能在 Activity 的 onCreate 方法中执行： Animator circularReveal = ViewAnimationUtils.createCircularReveal(text, 0, text.getHeight() , 1f, text.getWidth()*2); circularReveal.setDuration(1000); circularReveal.start(); 使用 ripple 标签或者 RippleDrawable 可以更改控件水波纹动画颜色： &lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;#00ff00&quot;&gt; &lt;item android:id=&quot;@android:id/mask&quot; &gt; &lt;color android:color=&quot;#0000ff&quot; /&gt; 定义带有属性动画的状态选择器 通过 stateListAnimator 属性指定状态选择器的动画： android:stateListAnimator=&quot;@drawable/selector_anim&quot; 状态选择器文件中需要加入 objectAnimator 标签： &lt;selector xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:statepressed = &quot;true&quot; &gt; &lt;objectAnimator android:propertyName = &quot;scaleX&quot; android:duration = &quot;@android:integer/configshortAnimTime&quot; android:valueTo = &quot;0.2&quot; android:valueFrom = &quot;1&quot; android:valueType = &quot;floatType&quot; &gt; //... 同样，状态选择器动画可以用代码方式加载 //加载动画 AnimatorInflater.loadStateListAnimator(); //设置动画 View.setStateListAnimator(); 定义带有帧动画的状态选择器，需要设置给 background 属性，不是 stateListAnimator，如下所示: &lt;animated-selector xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:id = &quot;@+id/pressed&quot; android:drawable = &quot;@drawable/drawableP&quot; android:state_pressed = &quot;true&quot; /&gt; &lt;item android:id = &quot;@id/default&quot; android:drawable = &quot;@drawable/drawableD&quot; /&gt; &lt;!-- 指定帧动画 - -&gt; &lt;transition android:fromId = &quot;@+id/default&quot; android:toId = &quot;@+id/pressed&quot; &gt; &lt;animation-list&gt; &lt;item android:duration = &quot;15&quot; android:drawable = &quot;@drawable/dt1 &quot;/&gt; &lt;item android:duration = &quot;15&quot; android:drawable = &quot;@drawable/dt2&quot;/&gt; ... &lt;/animation-list&gt; &lt;/animated-selector&gt; CardViewCardLayout 拥有高度和阴影，以及轮廓裁剪，圆角等功能 各属性说明: 1.设置圆角：card_view:cardCornerRadius=”10dp”2.设置高度：card_view:cardElevation=”10dp”3.设置内边距：card_view:contentPadding=”10dp”4.设置背景色：card_view:cardBackgroundColor=”?android:attr/colorPrimary” View 的高度与阴影官网介绍 View 新增属性 z 轴，用来体现 Material Design 中的层次，影响因素 2 个：elevation 和 translationZ View 高度 = elevation + translationZ elevation 表示 view 的高度，高度越大，阴影越大，可以在 xml 中直接使用属性， 也可以在代码中使用 view.setEvelvation(); android:elevation=&quot;10dp&quot; transtionZ 属性表示 view 在 Z 方向移动的距离，一般用于属性动画中 android:translationZ=&quot;10dp&quot; 高度影响 View 的绘制顺序，过去是按 View 添加顺序绘制，先添加的先绘制，现在高度小的先绘制，因为高度小的，层级低，在下面， 高度相同的，按添加顺序绘制 注意： 如果 View 的背景色为透明，则不会显示出阴影效果 只有子 View 的大小比父 View 小时，阴影才能显示出来 View 的轮廓与裁剪(在Android 5.1 以及以上才有效果) 官网介绍 View 增加了轮廓概念,轮廓用来表示怎么显示阴影,也就是说轮廓什么形状，阴影就显示什么形状。 View 的轮廓可以通过 outlineProvider 属性设置，默认是依据于 background 的，还有其他 3 个取值：bounds,none,paddingBounds android:outlineProvider=&quot;bounds&quot; none：即使设置了 evaluation 也不显示阴影background：按背景来显示轮廓，如果 background 是颜色值，则轮廓就是 view 的大小，如果是shape，则按 shape 指定的形状作为轮廓bounds: View 的矩形大小作轮廓paddedBounds: View 的矩形大小减去 padding 的值后的大小作轮廓。 可以通过 setOutlineProvider() 方法自定义轮廓: tv_blue.setOutlineProvider(new ViewOutlineProvider() { @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void getOutline(View view, Outline outline) { outline.setOval(0,0, view.getWidth(),view.getHeight()); } }); 注意：如果 background 是图片，那只能通过代码 setOutlineProvider() 来指定轮廓View 的裁剪是指将 View 按照轮廓裁剪，能改变 View 的形状，如圆形头像： 先设置轮廓:再设置根据轮廓裁剪 View,目前只支持对矩形，圆形，圆角矩形的裁剪: //设置对View进行裁剪 tv_clip.setClipToOutline(true); Palette使用 Palette 可以让我们从一张图片中拾取颜色，将拾取到的颜色赋予 ActionBar，StatusBar 以及背景色可以让界面色调实现统一使用 Palette 需要添加以下依赖： compile &apos;com.android.support:palette-v7:23.0.0+&apos; Palette 提供的 API 传入 Bitmap 即可获取 Palette 对象,以下是同步和异步使用方式: //同步获取，需要在子线程中使用 Palette palette = Palette.from(drawable.getBitmap()).generate(); //异步获取，可以在主线程中使用 Palette.from(drawable.getBitmap()).generate(new Palette.PaletteAsyncListener() { @Override public void onGenerated(Palette palette) { //... } }); 得到Palette对象后，获取其中的颜色，颜色对应如下： vibrant - 有活力的颜色lightVibrant - 有活力的亮色darkVibrant - 有活力的暗色muted - 柔和暗淡的颜色lightMuted - 柔和的亮色darkMuted - 柔和的暗色 获取指定颜色的采样对象，获取采样得到的颜色: //我们可以直接使用 palette 获取指定颜色： palette.getLightMutedColor(defaultColor); //一般也可以先获取采样对象 Swatch,从 Swatch 中获取我们需要的颜色: //获取有活力颜色的采样对象 Palette.Swatch vibrantSwatch = palette.getVibrantSwatch(); 采样对象Swatch提供了以下方法来获取颜色： //swatch.getPopulation(): the amount of pixels which this swatch represents. //swatch.getRgb(): the RGB value of this color. //swatch.getHsl(): the HSL value of this color，即色相，饱和度，明度. //swatch.getBodyTextColor(): the RGB value of a text color which can be displayed on top of this color. //swatch.getTitleTextColor(): the RGB value of a text color which can be displayed on top of this color //一般会将getRgb设置给控件背景色，getBodyTextColor()设置给文字颜色 textView.setBackgroundColor(vibrantSwatch.getRgb()); textView.setTextColor(vibrantSwatch.getBodyTextColor()); Android 5.0 新特性的向下兼容可以通过Support Library使用的新特性可以向下兼容，如： RecyclerView (recyclerview-v7) CardView (cardview-v7) Palette 颜色识别 (palette-v7) ToolBar (appcompat-v7) SwipeRefreshLayout (v4) 定义针对版本的资源目录 layout：使用新API的布局放在res/layout-v21中，其他的放res/layout drawable：使用新属性的drawable文件放到 res/drawable-v21，其他的放 res/drawable values: 新的主题放到 res/values-v21, 其他的放 res/values 在代码中对系统 Version 做判断，使用对应的效果，如: if(Build.VERSION.SDK_INT&gt; 21){ //使用新动画 ... }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客网站建设中的一些体会和记录]]></title>
      <url>%2F2017%2F05%2F11%2F%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A%E5%92%8C%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[使用过程中由于不恰当的操作会导致本地仓库和服务器仓库不一致无法推送到服务器等情况，该帖专门用于记录使用过程中的出现的一些错误的记录。 其实这个博客的仓库已经被我删除过好几次了，我确信我还不是一个好站长。网站使用过程中的各种问题有待一一去解决。 本地仓库提交之后无法推送到服务器中，尝试更改了仓库，之后切换回来时换了主题，再切回主题又好了，猜测是本地仓库的问题，具体未知。 推送后的更新有些慢，一度以为更新失败，之前也有延迟，但是延迟没有这么久，猜测是不是要更新的文件多了以至于影响速度。 永久链接设置过了，由之前的年/月/日/标题形式改为年/标题的形式，更改的原因是文章的更新问题，不过对于文章标题的更改影响应该是比较大的，目前针对这种情况永久链接估计也是无能为力的，由于对于 Google 的收录设置仍然存在问题，所有暂时无法检验永久链接设置是否生效了。值得注意的是直接使用标题并不是一种好的方式，因为会在站点目录中生成许多文件，并不能达到方便管理的目的，初步可以考虑以年/月/标题或者年/标题的形式来解决。实践发现这样操作也是存在问题的，目前发现的问题是向服务器中的推送问题，由于暂时未使用 debug 模式，具体原因还有待测试。 目前 Google 无法再收录新的站点更新，Google 承诺的站点删除功能也是有延迟的，在之前的科学上网部署 appId 时就有一些体会。因为当时官网中明确说明会在 7 天内处理 appId 的删除工作，但是实际使用过程中会出现延迟一个月的情况。 博客的持续更新确实能考验一个人的意志和执行能力，以后尽量每周都有一篇更新，但是不限于文章的内容。 目前服务器推送后不更新的一种已知情况是，本地仓库与服务器仓库文件不一致，出现这种情况的原因是直接在本地仓库或对于本地文件进行了增删改操作，影响了本地仓库记录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[140款Android开源优秀项目源码-菜鸟窝]]></title>
      <url>%2F2017%2F05%2F10%2F140%E6%AC%BEAndroid%E5%BC%80%E6%BA%90%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81-%E8%8F%9C%E9%B8%9F%E7%AA%9D%2F</url>
      <content type="text"><![CDATA[开源项目 BeautifulRefreshLayout-漂亮的美食下拉刷新 Material Design-动画风格的选项卡tab切换功能 TwinklingRefreshLayout-支持下拉刷新和上拉加载的RefreshLayout,自带越界回弹效果 DialogLoadding-Android开发之常用的loading等待效果实现，仿微博等待动画。两种实现方式详解 owspace-完整高仿单读的APP，模仿得非常精美，基于MVP+Dagger2+Retrofit2.0+Rxjava GSYVideoPlayer-android视频播放器，支持基本的拖动，声音、亮度调节，支持边播边缓存 NumberKeyboard-仿造android端闲鱼发布选择价格数字键盘自定义数字键盘 SwipeRecyclerView-自定义下拉刷新上拉加载控件SwipeRefreshLayout+recyclerView FloatingView-android能够让View执行漂亮的漂浮动画的库 TyperEditText-Android仿业问打字机效果，很炫酷 CircularMenu-android自动绘制遥控器界面CircularMenu ConnectListView-ConnectListView联动,listView三级联动 DylanStepCount-Android精准计步器(小米,魅族,华为上可用 MultiType-FilePicker-MultiType-FilePicker-android一款轻量级的文件选择器,支持多种文件类型 SuperTextView-一个功能强大的TextView,可以满足日常大部分布局方式 Android-SpinKit-Android-SpinKit多个漂亮的加载效果 PullToRefreshAndLoadMore-一个轻量下拉刷新上拉加载更多控件，已封装ListView BluetoothHelper-安卓蓝牙操作库，把蓝牙请求封装像Http一样 Luban-android最接近微信朋友圈的图片压缩算法 CBDialog-android一个快速创建对话框的工具类库 UserGuideView-androidy应用实现用户指引viewhttps://github.com/yilylong/UserGuideView okhttp一个让网络请求更简单的框架https://github.com/jeasonlzy/okhttp-OkGo TwinklingRefreshLayout-下拉刷新和上拉加载的RefreshLayout,自带越界回弹效果,支持RecyclerView,AbsListView,ScrollView,WebViewhttps://github.com/lcodecorex/TwinklingRefreshLayout StickerCamera-android一款集成了相机,图片裁剪,给图片贴贴图打标签的APPhttps://github.com/Skykai521/StickerCamera AndroidFire-一款新闻阅读App框架基于Material Desighttps://github.com/jaydenxiao2016/AndroidFire ViewPagerCards-android ViewPagerCards卡片切换效果源码https://github.com/rubensousa/ViewPagerCards Douya-Material Design 的豆芽客户端完整源码https://github.com/DreaminginCodeZH/Douya RestAPP-android网易云音乐界面源码https://github.com/sakurajiang/RestAPP huabanDemo-android 应用material design版的花瓣网Apphttps://github.com/LiCola/huabanDemo slidingtutorial-android-slidingtutorial-android创建视差效果引导页的库自定义强使用简单https://github.com/Cleveroad/slidingtutorial-android DropDownMenu-android实用的多条件筛选菜单,非popupWindow实现无卡顿https://github.com/dongjunkun/DropDownMenu CouponView-android开发半圆锯齿背景虚线边框组合实现简单优惠券效果https://github.com/dongjunkun/CouponView Tuikan-一款集知乎头条,美图，视频于一体的休闲阅读app源码https://github.com/homcin/Tuikan UPMiss-andoorid一个完整的生日管理Apphttps://github.com/qiujuer/UPMiss DropDownMenu-android完整的筛选器解决方案DropDownMenuhttps://github.com/baiiu/DropDownMenu StepView-android物流跟踪指示器StepViewhttps://github.com/baoyachi/StepView StylishMusicPlayer-一个超棒的Android Music Player源码https://github.com/ryanhoo/StylishMusicPlayer MaterialTabs-Material Design动画风格的选项卡tab切换功能https://github.com/neokree/MaterialTabs GankWithZhihu-阅读类App（MVP + RxJava + Retrofit）https://github.com/Werb/GankWithZhihu MyCalendarDemo-一款Android日历提醒软件https://github.com/Werb/MyCalendarDemo MaterialHome-基于Material Design的图书展示类完整app采用的是MD设计风格https://github.com/hymanme/MaterialHome UpdateDemo-android app自动检测更新库https://github.com/hugeterry/UpdateDemo TaoSchool-android一款基于Material Desgin设计的APPhttps://github.com/Hankkin/TaoSchool RecyclerViewCardGallery-android使用RecyclerView实现Gallery画廊效果https://github.com/huazhiyuan2008/RecyclerViewCardGallery/ CKCamera-android一个拍照并裁剪拍出照片的项目https://github.com/ChrisKyle/CKCamera SuperIndicator-android SuperIndicator 广告轮播源码https://github.com/hejunlin2013/SuperIndicator SignUpAnimation-android一个绚丽的注册动画界面https://github.com/qike2015/SignUpAnimation XRecyclerView-andorid RecyclerView下拉刷新，上拉加载更多https://github.com/jianghejie/XRecyclerView AutoInstaller-android应用自动下载静默安装https://github.com/a-voyager/AutoInstaller SeatTable-android在线电影票选座Demohttps://github.com/qifengdeqingchen/SeatTable android-adDialog-android一个简单强大的广告活动弹窗控件https://github.com/yipianfengye/android-adDialog Android-FilePicker-android图片和文档选择器https://github.com/DroidNinja/Android-FilePicker ViewPagerCards-android卡片切换效果ViewPagerCardshttps://github.com/rubensousa/ViewPagerCards/ CoCoin-一款完整的记账app(附带源码)https://github.com/Nightonke/CoCoin AndroidReview-一款面向Android开发者的一款面试复习Apphttps://github.com/envyfan/AndroidReview Douya-开源Material Design豆瓣客户端源码https://github.com/DreaminginCodeZH/Douya android脑筋急转弯（完整数据版）源码http://pan.baidu.com/s/1c17AWXM zkw6 DateScroller-探索日期滚轮控件的源码https://github.com/SpikeKing/DateScroller ZLayoutManager-五行代码实现 炫动滑动 卡片层叠布局，仿探探、人人影视订阅界面 简单&amp;优雅：LayoutManager+ItemTouchHelperhttps://github.com/mcxtzhang/ZLayoutManager RNPolymerPo-基于 React Native 的 Android 企业级应用 Demo。https://github.com/yanbober/RNPolymerPo BoomMenu-漂亮的菜单弹出控件 BoomMenuhttps://github.com/Nightonke/BoomMenu MobileSafe-MobileSafe 是一个下载过两万并且非常适合初学者学习的项目(没错就是黑马手机卫士)https://github.com/JessYanCoding/MobileSafe KuaiChuan-仿茄子快传的一款文件传输应用https://github.com/mayubao/KuaiChuan SImageView-一个实用方便的图片控件SImageViewhttps://github.com/suzeyu1992/SImageView WowSplash-不规则扩散的splashhttps://github.com/githubwing/WowSplash android-FancyBehaviorDemo-使用 CoordinatorLayout 实现复杂联动效果https://github.com/unixzii/android-FancyBehaviorDemo LbaizxfPulltoRefresh-仿健客、京东、天猫下拉刷新加载动画实现https://github.com/leibing8912/LbaizxfPulltoRefresh ZoomHeader-饿了么是怎么让Image变成详情页的https://github.com/githubwing/ZoomHeader XDroid-轻量级Android快速开发框架https://github.com/limedroid/XDroid CustomTextLayout-Android自定义组合控件（标题栏+组合布局）非常强大https://github.com/ithedan/CustomTextLayout QQ-高仿腾讯QQ，代码十分优雅https://github.com/HuTianQi/QQ YingBeautyNote-订个小目标，写个印象笔记https://github.com/HuTianQi/YingBeautyNote ZuiMeiTAG-用recyclerView实现最美应用底栏https://github.com/huage2580/ZuiMeiTAG ZuiMeiTAG-深入探索通知与插件的实时刷新https://github.com/SpikeKing/TimerAppWidget AnimationMenu-android 软软的动画弹出菜单，基于Facebook的Rebuondhttps://github.com/CarGuo/AnimationMenu WaveView-高仿百度外卖个人中心，让你的界面和我一起浪起来https://github.com/1139618418/WaveView shopcar-仿饿了么购物车下单效果https://github.com/917386389/shopcar RxJavaRetrofitOkhttpMvp-时下流行的RxJava+Retrofit+Okhttp+Mvp封装的一个demohttps://github.com/gslovemy/RxJavaRetrofitOkhttpMvp BitmapWaveView-安卓自定义View在bitmap中玩转大波浪进度https://github.com/AndroidMsky/BitmapWaveView Android-PickerView-Library-Android高仿ios pickerViewhttps://github.com/Airsaid/Android-PickerView-Library CustomNavigatorBar-Android通用标题栏组合控件https://github.com/wangluAndroid/CustomNavigatorBar SwipeDelMenuLayout-史上最简单，一步集成侧滑(删除)菜单，高仿QQ、IOShttps://github.com/mcxtzhang/SwipeDelMenuLayout DragFooterView-向左拖拽跳转至“更多页面”的通用控件https://github.com/uin3566/DragFooterView VRefreshLayout-Android下拉刷新控件之header置顶显示效果https://github.com/ileelay/VRefreshLayout TransitionHelper-两步实现类似格瓦拉的转场动画https://github.com/ImmortalZ/TransitionHelper DialogFragment-自定义对话框应该这样写https://github.com/GitPhoenix/DialogFragment RefreshLayout-RefreshLayout让你半小时以内完成一个列表界面https://github.com/gengqiquan/RefreshLayout SwipeCardRecyclerView-如何利用RecyclerView打造炫酷滑动卡片https://github.com/HalfStackDeveloper/SwipeCardRecyclerView LookLook-一个小时打造新闻apphttps://github.com/xinghongfei/LookLook JPTabBar-一款强大的Android底部导航https://github.com/peng8350/JPTabBar ByeBurger-炫酷：一句代码实现标题栏、导航栏滑动隐藏，ByeBurger库的使用和实现https://github.com/githubwing/ByeBurger CommonRecycler-通用 RecylerAdapter，内置 XRecyclerView，兼容上下拉与动画，高复用，一个 Adapter 通用所有页面，支持空页面，懒人专属https://github.com/CarGuo/CommonRecycler FreeBook-先定一个小目标!比如说先用MVP和快速开发框架打造一个免费下载小说的app老司机来手把手教你半天搞定https://github.com/80945540/FreeBook IjkPlayerView-基于ijkplayer的视频播放器，仿Bilibili客户端，集成沉浸式全屏、弹幕、触屏控制、视频源切换等功能https://github.com/Rukey7/IjkPlayerView CoolImageView-非常酷的图片组件，类似腾讯 QQ 可以让 imageview 的图片背景上下移动，或左右移动https://github.com/HuTianQi/CoolImageView AWelcomeVideoPager-ndroid酷炫欢迎页播放视频,仿蚂蜂窝自由行和慕课网https://github.com/linglongxin24/WelcomeVideoPager validateui-一个表单验证的libhttps://github.com/LongMaoC/validateui CollapseView-Android仿安居客房源详情页图片显示https://github.com/xiaoqiAndroid/CollapseView/tree/master HintPopupWindow-比QQ更炫酷的’选项弹窗’动画https://github.com/Zhaoss/HintPopupWindow RecyclerViewDemo2- 精通RecyclerView：打造ListView、GridView、瀑布流；学会添加分割线、 添加删除动画 、Item点击事件https://github.com/linglongxin24/RecyclerViewDemo2 TinderStackView-Android高仿「陌陌」的点点效果https://github.com/Mersens/TinderStackView MvpDemo-优雅的构建Android项目之 MVP开发模式https://github.com/PandaQAQ/MvpDemo Material Animations -演示View的平移、缩放动画，activity进入和退出动画，界面间元素共享，并且开发者在README中，对动画原理进行了精讲，是学习动画很好的项目，项目代码量比较少，也很适合新手学习。https://github.com/lgvalle/Material-Animations Meizhi-每天推送一张妹子图、一个小视频和一系列程序员精选文章，数据来源于代码家的干货集中营。唯一不足就是视频解析还有bug，声音视频无法同步，希望能尽快修复。https://github.com/drakeet/Meizhi android-UniversalMusicPlayer-这个开源项目展示了如何实现一个横跨各种Android平台的音乐播放器，包括手机，平板，汽车，手表，电视等。Google官方推出，跨平台开发必看项目。https://github.com/googlesamples/android-UniversalMusicPlayer plaid-由谷歌工程师开发，展示Google Material风格设计，项目代码量大，但是结构清晰，还是很好理解的。https://github.com/nickbutcher/plaid CalendarView-Android 滚轮日期选择自定义Viewhttps://github.com/chenpengfei88/CalendarView AndroidMVPSample-一套完整的Android通用框架https://github.com/WuXiaolong/AndroidMVPSample CoordinatorLayoutTest-高仿支付宝9.9.2版本生活模块界面来讲解CoordinatorLayout，AppBarLayout，CollapsingToolbarLayouthttps://github.com/jack921/CoordinatorLayoutTest SideSlip_PullToRefresh-Android 集成了RecyclerView 刷新加载，及侧滑菜单的 PullToRefreshhttps://github.com/lvfaqiang/SideSlip_PullToRefresh SideSlip_PullToRefresh-通用Android标题栏控件https://github.com/xiaohaibin/CustomTitileBar CalendarView-Android 自定义价格日历控件https://github.com/yissan/CalendarView ZhiHuDaily-纸飞机-采用MVP架构，集合了知乎日报、果壳精选和豆瓣一刻的综合性阅读客户端https://github.com/marktony/ZhiHuDaily ZhiHuDaily-仅2步实现 拜拜 汉堡导航栏效果~ 全新底部导航交互(滑动隐藏)https://github.com/githubwing/ByeBurger FloatBubbleView-Android：会呼吸的悬浮气泡https://github.com/IamXiaRui/Android_5.0_ViewDemo/tree/master/FloatBubbleView ByeBurger-极其简便的快速实现滑动隐藏标题栏和导航栏https://github.com/githubwing/ByeBurger NotificationUtil-全新的Android通知栏,已抛弃setLatestEventInfo,兼容高版本https://github.com/linglongxin24/NotificationUtil LauncherView-十分钟搞定酷炫动画，Android自定义 View 入门https://github.com/diamondlin2016/LauncherView LiveShow-使用MVP+RxJava制作的笑话APPhttps://github.com/GaoGersy/LiveShow ChargeProgress-android 自定义view+属性动画实现充电进度条功能https://github.com/crazyandcoder/ChargeProgress Notes-炫酷的ViewPager动画效果https://github.com/Elder-Wu/Notes ElasticLayout-超轻量！安卓实现多item抽屉效果动画https://github.com/AndroidMsky/ElasticLayout SuperTextView-SuperTextView 一款强大的android TextViewhttps://github.com/lygttpod/SuperTextView SuperTextView-自定义LayoutManager实现一个展示文章的View，支持拖动插入以及相应的动画展示https://github.com/rantianhua/AssembleEssay VideoRecord-Android 拍摄（横 \ 竖屏）视频的懒人之路https://github.com/CarGuo/VideoRecord Telegram-著名IM应用Telegram源码https://github.com/DrKLO/Telegram Notes-自定义View系列：未读消息数角标https://github.com/Elder-Wu/Notes BeautifulWords-Android开源实战：使用MVP+Retrofit开发一款文字阅读APPhttps://github.com/zuiwuyuan/BeautifulWords Notes-自定义ViewPager——左右无限循环，带指示器https://github.com/Elder-Wu/Notes Myprogress-安卓Android多阶段进度条progress bar附带动画效果https://github.com/AndroidMsky/Myprogress SpannableStringBiulderTest-直接拿去用！几种常见Dialog，懒人必收https://github.com/weavey/NormalSelectDialog SpannableStringBiulderTest-【Android】强大的SpannableStringBuilderhttps://github.com/Gavin-ZYX/SpannableStringBiulderTest Ghost-微影，一款纯粹的在线视频App，基于Material Design + MVP + RxJava + Retrofit + Realm + Glidehttps://github.com/GeekGhost/Ghost SwipeRecyclerView-自定义下拉刷新上拉加载控件（SwipeRefreshLayout + recyclerView）https://github.com/niniloveyou/SwipeRecyclerView ViewDragHelperDemo-Android自定义ViewGroup神器-ViewDragHelperhttps://github.com/hiphonezhu/Android-Demos/tree/master/ViewDragHelperDemo UserDefinedProgressBar-好玩的动画加载和自定义ProgressBarhttps://github.com/junmei520/UserDefinedProgressBar MPermissionUtils-Android6.0 运行时权限 超轻量级工具类https://github.com/Airsaid/MPermissionUtils EmptyLayout-Android通用的EmptyLayout-展示不用状态的界面https://github.com/yewei02538/EmptyLayout NestFullListView-【Android】ListView、RecyclerView、ScrollView里嵌套ListView 相对优雅的解决方案:NestFullListViewhttps://github.com/mcxtzhang/NestFullListView WindowMenuDemo-Android仿Qzone底部导航栏加号弹出菜单https://github.com/MjCodeTinker/WindowMenuDemo SmileRefresh-微笑下拉刷新。这是在 SwipeRefreshLayout基础上修改的下拉刷新库。https://github.com/songixan/SmileRefresh MyCartDemo-Android自定义View–自己撸一个柱状图也没那么难https://github.com/Hankkin/MyCartDemo MDStudySamples-Android TabLayout 分分钟打造一个滑动标签页https://github.com/Mike-bel/MDStudySamples WingUE-基本特效：饿了么丝滑无缝过度搜索栏的实现https://github.com/githubwing/WingUE 史上最牛逼的音乐播放器—仿网易云音乐（已开源）https://github.com/aa112901/remusic GABottleLoading-贝塞尔风暴 － 超炫GABottleLoading效果https://github.com/Ajian-studio/GABottleLoading PathAnimView-【注释张豪华版 Path酷炫动画】极速get花式Path （支付宝支付成功动画）https://github.com/mcxtzhang/PathAnimView Material Design : 带动画的标题栏https://github.com/shiguiyou/MaterialDemo/tree/master MultiTypeAdapter-优雅的实现多类型列表的Adapterhttps://github.com/LiHongHui6/MultiTypeAdapter AnimationPlayer-探索View动画和属性动画https://github.com/SpikeKing/AnimationPlayer AnimShopButton-仿饿了么加入购物车旋转控件 - 自带闪转腾挪动画 的按钮https://github.com/mcxtzhang/AnimShopButton YinyuetaiPlayer-高仿音悦台播放页面交互效果https://github.com/oubowu/YinyuetaiPlayer AndroidAnimationExercise-Android 动画实战 - 仿微博雷达功能https://github.com/REBOOTERS/AndroidAnimationExercise]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用链接]]></title>
      <url>%2F2017%2F04%2F25%2F%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5%2F</url>
      <content type="text"><![CDATA[个人收藏，常用链接。 招聘 智联招聘Boss 直聘 文件互传 爱莫 airmore闪传 xender 应用市场 apkpure 博客网站 zd423stormzhang 博客建设 hexo-theme-nexthexoatom.ioatom 引擎 GoogleBaiDuSougou gfsosocsdn 论坛 GitHubStack Overflowcsdn 产品 Google 云平台 gcloud config set project projectIdXxx gcloud beta app create –region us-central 注解 butterknifedagger1dagger2 规范 unbug codelfcheckstyle MaterialDesignLibraryretrolambda 图片 glidepicassoCircleImageView 二维码 zxing 网络 okhttp 数据库 greenDAO 内存 leakcanary 异步操作 RxAndroidRxJavaRxJava-collection 开源项目 EventBusretrofitJakeWharton ViewPagerIndicatorbaseAdapteropen-android Androidreact-nativefastJson Trinea open-projectTrinea android-commondaimajia AndroidSwipeLayoutYUtils ip 查询 网站 IP 信息查询IP 域国家国旗IP Address and Domain Information 翻译 划词翻译 标签页 infinityoneTab 科学上网 GoAgentXX-NethostsSwitchHostsgfw.pressSwitchyOmegagoproxylanternshadowsocks-windowsgfwssBetternet Unlimited Free VPN Proxy快速安全通道科学上网BroPro VPN代理氪星人的科学上网工具 短链接 Google wiki 其他avatars-for-githubisometric-contributionsoctotreePostmanChromeADB百度网盘下载助手掘金AtomEverythingsublimetextDiskGeniusUltraISOFoobar200PartitionGuruPotPlayer站长工具v2ex疯狂解析我正青年喵喵tumblryoutube clipconverter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中国大陆版权协议]]></title>
      <url>%2F2017%2F04%2F24%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E9%99%86%E7%89%88%E6%9D%83%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[支持知识产权保护，尊重知识创造，该文本包含知识共享和许可协议中的部分相关概念和一些链接。 题目： 署名-非商业性使用-相同方式共享 3.0 中国大陆 (CC BY-NC-SA 3.0 CN) 正文： 您可以自由地： 共享 — 在任何媒介以任何形式复制、发行本作品 演绎 — 修改、转换或以本作品为基础进行创作 只要你遵守许可协议条款，许可人就无法收回你的这些权利。 惟须遵守下列条件： 署名 — 您必须给出合适的 姓名或名称，提供许可协议链接，同时表明如果有修改。您可以合理的方式这样做，但是部分以任何方式暗示许可人同意您或您的使用。 非商业性使用 — 您不得将本作品用于商业目的。相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议 分发您贡献的作品。 没有附加限制 — 您不得适用法律术语或者技术措施 从而限制其他人做许可协议允许的事情。 声明： 您不必因为公共领域的作品要素而遵守许可协议，或者您的使用被可适用的例外或限制所允许。 不提供担保。许可协议可能不会给与您意图使用的所必须的所有许可。例如，其他权利比如形象权、隐私权或人格权 可能限制您如何使用作品。 知识共享 许可协议]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[即时通讯]]></title>
      <url>%2F2017%2F04%2F24%2F%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%2F</url>
      <content type="text"><![CDATA[即时通讯： IM 环信： 基础版，日活 30 万，免费。 PaaS 不生产实体产品（app），提供服务平台。app 服务器，用户信息的服务器，是开发软件自己的服务器， 环信只提供一个服务平台，通信通道。 数据安全，自己的服务器平台融云：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简述 23 种设计模式]]></title>
      <url>%2F2017%2F04%2F23%2F%E7%AE%80%E8%BF%B0-23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[写博客的初衷是以学习、记录、交流为主，文章中的思路是参照 Java开发中的23种设计模式详解，并加入了自己的一些思考和总结,参照的文章也是转载的，并指向 CSDN 博主终点，但未找到相应的文章，特此说明。 知乎中有框架与设计模式的区别的介绍。 分类总体分为 3 大类： 创建型模式：有 5 种，工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式：有 7 种，适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式：有 11 种，策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。 六大原则开闭原则（Open Close Principle）对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，类似于热插拔。 这是为了使程序具有扩展性，易于维护和升级。而想要达到这样的效果，我们需要使用接口和抽象类。 tips ：重构，代码不够好的时候，也可以考虑重构， but 有成本。扩展， 一代代码不够好的话，扩展相当于打补丁。 所以： 重构 + 基类 + 接口扩展 里氏代换原则 LSP Liskov Substitution Principle 面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 里氏代换原则是对“开-闭”原则的补充。实现 “开-闭原则” 的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现， 里氏代换原则是对实现抽象化的具体步骤的规范。 tip： 扩展/衍生类/子类 前提：基类功能不受影响 手段：要复用基类功能 目的：扩展/增加新功能、新特性 依赖倒转原则 Dependence Inversion Principle 这是开闭原则的基础，具体内容：针对接口编程、依赖于抽象而不依赖于具体。 tips：针对接口或者基类编程，高层次代码不能依赖低层次代码 接口隔离原则 Interface Segregation Principle 使用多个隔离的接口，比使用单个接口要好。有降低类之间耦合度的意思。 设计模式的设计思想是从大型软件架构出发，为了升级和维护方便。降低依赖，降低耦合。 tips ：接口过多也不方便管理，适用即可。高内聚，低耦合： 高内聚指的是单个类结构，是类的内部特征；低耦合指的是类与类之间的关系，是类的外部特征。 迪米特法则(最少知道原则) Demeter Principle 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 tips：不主动依赖，用构造传接口或者对象比 new 对象要好，new 对象是非原子性操作，耦合并没有被消灭，只是被转移到了接口或者基类上 3 种解耦合的注入方式：构造注入，接口注入， setter 注入。 合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 tips： 抽象/接口是最基础的，也是整体上的思想，而合成是将一些已经有的模块组合成为新的模块功能，而不是一味的去创建继承是有条件有代价的，继承是对已有功能的扩展但这种继承关系本身也是一种耦合，设计所能做的是减少耦合，或者松耦合，或者转移耦合方式，而不是消灭耦合 耦合本身指的是两个同类（比如说模块）之间的紧密程度，在 Android 中可以理解为两个类之间的关系，当设计可以让类与类之间的紧密关系降低时，我们就可以说是降低了耦合度，但实际上又和基类或者接口耦合了，这种耦合可以视为一种规范或者标准化。 高内聚，低耦合： 是指模块内部的功能单一，模块与模块间的紧密关系小。前者是指模块内部的关系，后者是指模块之间关系，两者不矛盾。 设计模式 1. 工厂方法： 3 种方式 共同的接口 public interface Sender { public void Send(); } 实现类 1 public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } 实现类 2 public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 普通工厂类 –&gt; 方式1 public class SendFactory { public Sender produce(String type) { if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 多个工厂方法的工厂类 –&gt; 方式 2 public Sender produceMail() { return new MailSender(); } public Sender produceSms() { return new SmsSender(); } 静态工厂方法的工厂类 –&gt; 方式 3 public class SendFactory { public static Sender produceMail() { return new MailSender(); } public static Sender produceSms() { return new SmsSender(); } } 总体来说，简单工厂模式（工厂方法）适合： 凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。 在以上的三种模式中 第一种如果传入的字符串有误，不能正确创建对象 第三种相对于第二种，不需要实例化工厂类。 大多数情况下，我们会选用第三种 ——&gt; [静态工厂方法模式]。 抽象工厂模式（Abstract Factory）工厂方法模式有一个问题就是，类的创建依赖工厂类 也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则： 不闭包可以理解为 ： 使用有条件的，有细节的，通用性要低 从设计角度考虑，有一定的问题，如何解决？ 就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 tips ： 这里把修改转移到了增加 修改对应的是原来的，而增加是扩展的 — &gt; 遵循开闭原则，扩展而不是修改已有的 //1. 接口 public interface Sender { public void Send(); } //2. 接口实现类 1 public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } //2. 接口实现类 2 public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } //3. 工厂接口 public interface Provider { public Sender produce(); } //4. 工厂类 1 public class SendMailFactory implements Provider { ​ @Override public Sender produce(){ return new MailSender(); } } //4. 工厂类 2 public class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } 其实这个模式的好处就是，如果想增加一个功能：发及时信息，则只需 1.创建一个实现类（模块类），实现 Sender 接口 2.创建一个工厂类，实现 Provider 接口 就OK了，无需去改动现成的代码。这样做，拓展性较好！ tips： 扩展性的好坏不是一定的，项目的规模大小也会影响。 假设要增加 100 个模块类，那就要创建 200个类，这种情况下，该设计模式可能就不具有优势了。 单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。 在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。2、省去了 new 操作符，降低了系统内存的使用频率，减轻 GC 压力。3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。 // 方式 1. 简单单例 不适用于多线程 – &gt; 单例两种方式 1. 饿汉式：空间换时间 2. 懒汉式： 时间换空间 延时加载 public class Singleton { /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 静态工程方法，创建实例 */ public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } // 方式 2. 方法同步锁，锁类 ，影响性能 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } // 方式 3. 双重锁机制 ---- &gt; 懒汉式 public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } // 饿汉式 ：直接创建对象 public class Singleton{ private static Singleton singleton = new Singleton (); private Singleton (){} public static Singleton getInstance(){ return singletion; } } 设计模式 4建造者模式（Builder） 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象， 所谓复合对象就是指某个类具有不同的属性。 // 借用以上 Sender 接口及其 2 个实现类 public class Builder { ​ private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new MailSender()); } } public void produceSmsSender(int count){ for(int i=0; i&lt;count; i++){ list.add(new SmsSender()); } } } 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。 所以与工程模式的区别就是： 工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。 因此，是选择工厂模式还是建造者模式，依实际情况而定。 tips ：框架中常见的一种使用场景是链式调用。 原型模式（Prototype）原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出， 该模式的思想就是：将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。 public class Prototype implements Cloneable { // cloneable 是空方法 public Object clone() throws CloneNotSupportedException { Prototype proto = (Prototype) super.clone(); return proto; } } 适配器模式适配器模式将某个类的接口转换成客户端期望的另一个接口表示 目的是消除由于接口不匹配所造成的类的兼容性问题。 主要分为 3 类：类的适配器模式、对象的适配器模式、接口的适配器模式。 核心思想就是： 有一个 Source 类，拥有一个方法，待适配 目标接口 Targetable，通过 Adapter 类，将 Source 的功能扩展到 Targetable 里。 类的适配器 // 1.1 public class Source { public void method1() { System.out.println(&quot;this is original method!&quot;); } } // 1.2 接口 public interface Targetable { /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); } // 1.3 类适配 public class Adapter extends Source implements Targetable { @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } } 对象的适配器模式： 基本思路和类的适配器模式相同： 只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。 // 1.3 对象适配 public class Wrapper implements Targetable { private Source source; public Wrapper(Source source){ super(); this.source = source; } @Override public void method2() { System.out.println(&quot;this is the targetable method!&quot;); } @Override public void method1() { source.method1(); } } 接口适配器 第三种适配器模式是接口的适配器模式，接口的适配器是这样的： 有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的， 有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式 借助于一个抽象类，该抽象类实现了该接口， 实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系， 所以我们写一个类，继承该抽象类，重写我们需要的方法就行。 接口 public interface Sourceable { ​ public void method1(); public void method2(); } 抽象类 public abstract class Wrapper2 implements Sourceable{ ​ public void method1(){} public void method2(){} } 子类1 public class SourceSub1 extends Wrapper2 { // @Override //选择性重写 public void method1(){ System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); } } 子类 2 public class SourceSub2 extends Wrapper2 { //@Override //选择性重写 public void method2(){ System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); } } 3 种适配器模式的应用场景： 类的适配器模式： 当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式： 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式： 当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 装饰者模式顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下： // 1. 接口 public interface Sourceable { public void method(); } // 2. 被装饰类 public class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } } // 3. 装饰类 public class Decorator implements Sourceable { private Sourceable source; public Decorator(Sourceable source){ super(); this.source = source; } @Override public void method() { System.out.println(&quot;before decorator!&quot;); source.method(); System.out.println(&quot;after decorator!&quot;); } } tips ：好像不要接口也是可以的 不细究了，不过对于被装饰类的方法是私有的或者是不同的人操作的，可能要考虑一些问题了。 装饰器模式的应用场景： 1、需要扩展一个类的功能。2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ 代理模式其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作 e.g.比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。 // 1.接口 public interface Sourceable { public void method(); } // 2. 实现类 public class Source implements Sourceable { @Override public void method() { System.out.println(&quot;the original method!&quot;); } } // 3. 代理类 public class Proxy implements Sourceable { private Source source; public Proxy(){ super(); this.source = new Source(); } @Override public void method() { before(); source.method(); atfer(); } private void before() { System.out.println(&quot;before proxy!&quot;); } private void atfer() { System.out.println(&quot;after proxy!&quot;); } } 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有 2 种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 外观模式（Facade）外观模式是为了解决类与类之间的依赖关系的， 像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口 // cpu public class CPU { ​ public void startup(){ System.out.println(&quot;cpu startup!&quot;); } public void shutdown(){ System.out.println(&quot;cpu shutdown!&quot;); } } // memory public class Memory { ​ public void startup(){ System.out.println(&quot;memory startup!&quot;); } public void shutdown(){ System.out.println(&quot;memory shutdown!&quot;); } } // disk public class Disk { ​ public void startup(){ System.out.println(&quot;disk startup!&quot;); } public void shutdown(){ System.out.println(&quot;disk shutdown!&quot;); } } // 计算机 public class Computer { private CPU cpu; private Memory memory; private Disk disk; public Computer(){ cpu = new CPU(); memory = new Memory(); disk = new Disk(); } public void startup(){ System.out.println(&quot;start the computer!&quot;); cpu.startup(); memory.startup(); disk.startup(); System.out.println(&quot;start computer finished!&quot;); } public void shutdown(){ System.out.println(&quot;begin to close the computer!&quot;); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(&quot;computer closed!&quot;); } } // User 用户 public class User { public static void main(String[] args) { Computer computer = new Computer(); computer.startup(); computer.shutdown(); } } 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！ tips: 这个类之间的耦合也是蛮大 参考资料应该是 JAVA ，13 年的 桥接模式（Bridge）桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。 桥接的用意是： 将抽象化与实现化解耦，使得二者可以独立变化 像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候， 在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动， 原因就是： JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 // 1. 接口： public interface Sourceable { public void method(); } // 2.1 实现类 1 public class SourceSub1 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the first sub!&quot;); } } // 2.2 实现类 2 public class SourceSub2 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the second sub!&quot;); } } // 3. 定义一个桥，持有Sourceable的一个实例： public abstract class Bridge { private Sourceable source; public void method(){ source.method(); } public Sourceable getSource() { return source; } public void setSource(Sourceable source) { this.source = source; } } public class MyBridge extends Bridge { public void method(){ getSource().method(); } } 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。 组合模式（Composite）组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便 public class TreeNode { ​ private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); ... setter getter //添加孩子节点 public void add(TreeNode node){ children.add(node); } //删除孩子节点 public void remove(TreeNode node){ children.remove(node); } //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren(){ return children.elements(); } } public class Tree { TreeNode root = null; public Tree(String name) { root = new TreeNode(name); } public static void main(String[] args) { Tree tree = new Tree(&quot;A&quot;); TreeNode nodeB = new TreeNode(&quot;B&quot;); TreeNode nodeC = new TreeNode(&quot;C&quot;); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(&quot;build the tree finished!&quot;); } } 使用场景： 将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 享元模式（Flyweight）享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时， 工厂需要检查当前对象池中是否有符合条件的对象， 1. 如果有，就返回已经存在的对象， 2. 如果没有，则创建一个新对象，FlyWeight是超类。 一提到共享池，我们很容易联想到Java里面的JDBC连接池， 想想每个连接的特点，我们不难总结出： 适用于作共享的一些个对象，他们有一些共有的属性： 就拿数据库连接池来说： url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的， 所以就适合用享元模式来处理： 建一个工厂类，将上述类似属性作为内部数据， 其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 // 数据库连接池的代码： public class ConnectionPool { ​ private Vector&lt;Connection&gt; pool; /*公有属性*/ // ---&gt; public private String url = &quot;jdbc:mysql://localhost:3306/test&quot;; private String username = &quot;root&quot;; private String password = &quot;root&quot;; private String driverClassName = &quot;com.mysql.jdbc.Driver&quot;; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() { pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) { try { Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } } /* 返回连接到连接池 */ public synchronized void release() { pool.add(conn); } /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() { if (pool.size() &gt; 0) { Connection conn = pool.get(0); pool.remove(conn); return conn; } else { return null; } } } 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！ 第一类：通过父类与子类的关系进行实现。 第二类：两个类之间。 第三类：类的状态。 第四类：通过中间类 策略模式（strategy）策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。 图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类： // 1. 统一接口： public interface ICalculator { public int calculate(String exp); } // 2. 辅助类： public abstract class AbstractCalculator { ​ public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } // 实现类 1 public class Plus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\+&quot;); return arrayInt[0]+arrayInt[1]; } } // 实现类 2 public class Minus extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;-&quot;); return arrayInt[0]-arrayInt[1]; } } // 实现类 3 public class Multiply extends AbstractCalculator implements ICalculator { @Override public int calculate(String exp) { int arrayInt[] = split(exp,&quot;\\*&quot;); return arrayInt[0]*arrayInt[1]; } } 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 模板方法模式（Template Method）模板方法模式： 1. 1 个抽象类中，有 1 个主方法，n 个抽象的或实际的方法 2. 继承抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用 就是在 AbstractCalculator 类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用 public abstract class AbstractCalculator { ​ /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt){ int array[] = split(exp,opt); return calculate(array[0],array[1]); } /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt){ String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; } } public class Plus extends AbstractCalculator { @Override public int calculate(int num1,int num2) { return num1 + num2; } } 我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。 观察者模式（Observer）包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。 观察者模式很好理解： 类似于邮件订阅和RSS订阅， 当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章， 如果后续有更新，会及时通知你。 简单来讲： 当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。 这些类的作用： MySubject类就是我们的主对象， Observer1和Observer2是依赖于MySubject的对象， 当MySubject变化时，Observer1和Observer2必然变化。 AbstractSubject类中定义着需要监控的对象列表， 可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象 // 一个Observer接口： public interface Observer { public void update(); } // 实现类1 public class Observer1 implements Observer { @Override public void update() { System.out.println(&quot;observer1 has received!&quot;); } } // 实现类2 public class Observer2 implements Observer { @Override public void update() { System.out.println(&quot;observer2 has received!&quot;); } } //Subject接口及实现类： public interface Subject { ​ /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); } public abstract class AbstractSubject implements Subject { private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) { vector.add(observer); } @Override public void del(Observer observer) { vector.remove(observer); } @Override public void notifyObservers() { Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements()){ enumo.nextElement().update(); } } } public class MySubject extends AbstractSubject { @Override public void operation() { System.out.println(&quot;update self!&quot;); notifyObservers(); } } 这些东西有些抽象，不太容易整体理解， 建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）, 按照总体思路走一遍，这样才能体会它的思想，理解起来容易！ 迭代子模式（Iterator）顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见， 如果对集合类比较熟悉的话，理解本模式会十分轻松。 这句话包含两层意思： 一是需要遍历的对象，即聚集对象 二是迭代器对象，用于对聚集对象进行遍历访问。 这个思路和我们常用的一模一样： MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例 //接口 1 public interface Collection { ​ public Iterator iterator(); /*取得集合元素*/ public Object get(int i); /*取得集合大小*/ public int size(); } // 接口 2 public interface Iterator { //前移 public Object previous(); //后移 public Object next(); public boolean hasNext(); //取得第一个元素 public Object first(); } // 实现 1 public class MyCollection implements Collection { public String string[] = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; @Override public Iterator iterator() { return new MyIterator(this); } @Override public Object get(int i) { return string[i]; } @Override public int size() { return string.length; } } // 实现 2 public class MyIterator implements Iterator { private Collection collection; private int pos = -1; public MyIterator(Collection collection){ this.collection = collection; } @Override public Object previous() { if(pos &gt; 0){ pos--; } return collection.get(pos); } @Override public Object next() { if(pos&lt;collection.size()-1){ pos++; } return collection.get(pos); } @Override public boolean hasNext() { if(pos&lt;collection.size()-1){ return true; }else{ return false; } } @Override public Object first() { pos = 0; return collection.get(pos); } } 此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？ 其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！ 责任链模式（Chain of Responsibility）责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求， 所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。 Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。 public interface Handler { public void operator(); } public abstract class AbstractHandler { ​ private Handler handler; public Handler getHandler() { return handler; } public void setHandler(Handler handler) { this.handler = handler; } } public class MyHandler extends AbstractHandler implements Handler { private String name; public MyHandler(String name) { this.name = name; } @Override public void operator() { System.out.println(name+&quot;deal!&quot;); if(getHandler()!=null){ getHandler().operator(); } } } 此处强调一点就是： 链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。 命令模式（Command）命令模式的理解： 举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。 Invoker是调用者（司令员）Receiver是被调用者（士兵）MyCommand是命令，实现了Command接口，持有接收对象 public interface Command { public void exe(); } public class MyCommand implements Command { private Receiver receiver; public MyCommand(Receiver receiver) { this.receiver = receiver; } @Override public void exe() { receiver.action(); } } public class Receiver { public void action(){ System.out.println(&quot;command received!&quot;); } } public class Invoker { ​ private Command command; public Invoker(Command command) { this.command = command; } public void action(){ command.exe(); } } public class Test { public static void main(String[] args) { Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); } } 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开， Struts中：Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。 第三类和第四类。备忘录模式（Memento）主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象， 叫备份模式更形象些 通俗的讲下： 假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。 Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。 public class Original { ​ private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public Original(String value) { this.value = value; } public Memento createMemento(){ return new Memento(value); } public void restoreMemento(Memento memento){ this.value = memento.getValue(); } } public class Memento { ​ private String value; public Memento(String value) { this.value = value; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } public class Storage { ​ private Memento memento; public Storage(Memento memento) { this.memento = memento; } public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } 简单描述下： 新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。 状态模式（State）核心思想就是： 当对象的状态改变时，同时改变其行为，很好理解！ 就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态， 所以，状态模式就两点： 1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。 // State类是个状态类，Context类可以实现切换 public class State { ​ private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public void method1(){ System.out.println(&quot;execute the first opt!&quot;); } public void method2(){ System.out.println(&quot;execute the second opt!&quot;); } } public class Context { private State state; public Context(State state) { this.state = state; } public State getState() { return state; } public void setState(State state) { this.state = state; } public void method() { if (state.getValue().equals(&quot;state1&quot;)) { state.method1(); } else if (state.getValue().equals(&quot;state2&quot;)) { state.method2(); } } } 根据这个特性，状态模式在日常开发中用的挺多的， 尤其是做网站的时候，我们有时希望根据对象的某一属性， 区别开他们的一些功能，比如说简单的权限控制等。 访问者模式（Visitor）访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。 访问者模式适用于： 数据结构相对稳定算法又易变化的系统。 因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。 访问者模式的优点： 是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。 其缺点是： 增加新的数据结构很困难。 简单来说: 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离， 可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 // 一个Visitor类，存放要访问的对象， public interface Visitor { public void visit(Subject sub); } public class MyVisitor implements Visitor { @Override public void visit(Subject sub) { System.out.println(&quot;visit the subject：&quot;+sub.getSubject()); } } // Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性， public interface Subject { public void accept(Visitor visitor); public String getSubject(); } public class MySubject implements Subject { @Override public void accept(Visitor visitor) { visitor.visit(this); } @Override public String getSubject() { return &quot;love&quot;; } } 该模式适用场景： 如果我们想为一个现有的类增加新功能，不得不考虑几个事情： 1、新功能会不会与现有功能出现兼容性问题？ 2、以后会不会再需要添加？ 3、如果类不允许修改代码怎么办？ 面对这些问题，最好的解决方法就是: 使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦 中介者模式（Mediator）中介者模式也是用来降低类类之间的耦合的： 因为如果类类之间有依赖关系的话， 不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。 如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行， 这有点像spring容器的作用。 User类统一接口，User1和User2分别是不同的对象，二者之间有关联 如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高， 为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类， 里面持有User1和User2的实例，用来实现对User1和User2的控制。 这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行， 剩下的全由MyMediator类来维护！基本实现： public interface Mediator { public void createMediator(); public void workAll(); } public class MyMediator implements Mediator { private User user1; private User user2; public User getUser1() { return user1; } public User getUser2() { return user2; } @Override public void createMediator() { user1 = new User1(this); user2 = new User2(this); } @Override public void workAll() { user1.work(); user2.work(); } } public abstract class User { ​ private Mediator mediator; public Mediator getMediator(){ return mediator; } public User(Mediator mediator) { this.mediator = mediator; } public abstract void work(); } public class User1 extends User { public User1(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user1 exe!&quot;); } } public class User2 extends User { public User2(Mediator mediator){ super(mediator); } @Override public void work() { System.out.println(&quot;user2 exe!&quot;); } } 解释器模式（Interpreter）一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。 //Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现 public interface Expression { public int interpret(Context context); } public class Plus implements Expression { @Override public int interpret(Context context) { return context.getNum1()+context.getNum2(); } } public class Minus implements Expression { @Override public int interpret(Context context) { return context.getNum1()-context.getNum2(); } } public class Context { ​ private int num1; private int num2; public Context(int num1, int num2) { this.num1 = num1; this.num2 = num2; } public int getNum1() { return num1; } public void setNum1(int num1) { this.num1 = num1; } public int getNum2() { return num2; } public void setNum2(int num2) { this.num2 = num2; } } 基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[版权声明]]></title>
      <url>%2F2017%2F04%2F22%2F%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%2F</url>
      <content type="text"><![CDATA[创建该博客网站是受 stormzhang 的影响，写博客的初衷也是以学习、记录、交流为主，若网站博客中有侵权、未注明明显出处等情况发生，请用邮箱联系我。 对于博客中涉及类似侵权、未在明显位置注明出处等行为，请原创作者原谅，这非博主本意，可能参照的东西太多未细分或者疏忽导致。 另外，本站博客可任意转载，不必获取授权或者带有转载等字眼。但若发生被转载的文章是本站博客中的非原创作品，而转载者又未声明版权所有者等类似情况的，请转载者自行负责。 本版权声明长期有效，未尽事宜，请用邮箱联系我，Email：m8538343069@foxmail.com。 04/22/2017 Jan9th]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于 Hexo]]></title>
      <url>%2F2017%2F04%2F22%2FAbout-Hexo%2F</url>
      <content type="text"><![CDATA[快速上手 欢迎访问 Hexo ，点击 文档 查看更多信息。若使用 Hexo 过程中有任何问题，可以访问 问题解答 或者 Hexo issues 查看解决方案。 创建一个 post 文件1$ hexo new "Hello Hexo" 更多信息： 写作 运行本地调试服务1$ hexo server 更多信息： 服务器 生成静态文件1$ hexo generate 更多信息： 生成文件 部署到远程仓库1$ hexo deploy 更多信息： 部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo NexT 使用中的小细节]]></title>
      <url>%2F2017%2F04%2F22%2FHexo-NexT-%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[Hexo NexT 应用中的小技巧，使用过程中不定期更新。 中文模式 站点：language: zh-Hans 更新生效 主题配置和文章，修改后刷新浏览器可以直接生效；站点配置更改需要重新生成才能生效。 本地搜索 安装 hexo-generator-searchdb 插件，执行 npm install hexo-generator-searchdb --save 增加站点配置，如下：&gt; search: path: search.xml field: post format: html limit: 10000 创建分类 创建分类页 hexo new page categories 分类页 index.md 增加 type: &quot;categories&quot; 实现分类跳转 创建 tag 页 创建 tag 页 hexo new page tags tag 页 index.md 增加 type: &quot;tags&quot; 实现 tag 跳转 more 字段 使用 NexT 主题可以在文章中增加 &lt;!--more--&gt; ，more 字段上的为摘要。 修改模版 scaffolds 文件夹中 post.md page.md draft.md 文件为模版文件 --#- title: {{ title }} categories: tags: comments: false --#- &lt;!#--more--&gt; 去掉所有的 # 成为自定义模版文件 多 tag tag: [Hexo,NexT] 英文符号，中间有个空格。 创建草稿 hexo new draft Hello 在 source/-drafts 下生成 Hello.md 文件 默认不预览，网站配置 render_drafts 节点更改渲染/预览。 或使用 hexo server --drafts 开启临时预览。 发布草稿 hexo publish Hello 多个分类 同一篇文章不支持两个分类字数统计 更改 \themes\next\ _config.yml 中 busuanzi_count 节点 执行npm install hexo-wordcount --save 插件名后加 @2.0.1 指定版本 打赏禁止动画 next/source/css/_common/components/post/post-reward.styl 中注释 alipay 和 wechart 动画 内链颜色 themes\next\source\css\_common\components\post\post.styl 中自定义样式&gt; .post-body p a{color: #0593d3; border-bottom: none; &amp;:hover { color: #0477ab; text-decoration: underline; } } 查看版本 使用 hexo -v 卸载 npm uninstall hexo-cli -g # 未实践过npm remove hexo-generator-searchdb 置顶 使用 npm install --save hexo-generator-index 插件，多个置顶按等级和时间顺序。 更改 ../node_modules/hexo-generator-index/lib/generator.js 文件 文章中增加 top: true 配置 版权所有者：Netcan_Space :解决 Hexo 置顶问题 ico 转换 在线制作工具 网站标签页 Hexo系列教程之三：next主题的配置和优化 站点收录 $ npm install hexo-generator-baidu-sitemap --save$ npm install hexo-generator-sitemap --save 网站配置中增加节点 sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 生成，预览$ hexo g$ hexo s如果不生效就先执行$ hexo clean 版权所有者：svendHexo系列：(四)Hexo博客提交百度和Google收录 远程仓库更改 仓库地址查看 git remote -v 更换仓库 git remote set-url origin &lt;repo&gt; 空仓库添加仓库 git remote add origin &lt;repo&gt; 本地仓库改名 git remote rename [current name] [new name] 移除本地仓库名 git remote rm origin 此操作所有 origin 均会被移除可视化操作 插件 `npm install hexo-hey --save` site config： admin: name: hexo password: hey secret: hey hexo expire: 60*1 访问： localhost:4000/admin 插件地址参考 域名绑定四大一级免费域名： tk cf ml ga 步骤： 域名查询可用 域名注册 个人网站添加 CNAME 文件或其他类型，内容是域名，注意文件无扩展名 域名解析商网站添加待解析的域名（即域名注册商处指定域名解析地址） 域名注册商处修改域名地址为域名解析商提供的解析名 全球递归DNS服务器刷新等待 24h ~ 72h 生效 域名解析流向： 域名注册商–&gt; 域名解析商–&gt; 个人域名 Freenom十大免费DNS域名解析服务参考DNSPod/Tencent DNS 解析DNS 原理 经实践：阿里云解析 cf 域名失败，有的网页甚至不识别 cf 域名，不明白具体的是怎么回事，有说 freenom 不支持第三方解析的，未知。 错误警告 warning: LF will be replaced by CRLF in XXXXXXXXXXXXXX.的警告。git config --global core.autocrlf false unix/Linux/mac/windows 不同系统对应回车、换行的定义不一样，Git 存储时，有针对于 不同平台间的转换，是某种操作导致了这种转换被开启，与二进制存储时是否可逆有关系，具体的不是十分明白。 全面教程格子林ll 简书 自动构建安装和设置部分： ruby -v # ruby 2.2.6p396 (2016-11-15 revision 56800) [x64-mingw32] gem install travis -v 1.8.8 –no-rdoc –no-ri travis version # 1.8.8 –&gt; travis is ok 设置 Travis CI Hook 的 github name 和 travis token 部署： 待进行…… 持续集成RubyWindows Ruby]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于 Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F19%2F%E5%9F%BA%E4%BA%8E-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[摘要 博客由 GitHub 托管，采用 GitHub Pager 静态网页 + Hexo 博客框架 + NexT 主题，本文介绍了博客搭建的关键步骤。 工具安装安装 Node.js 自定义安装路径，其余默认配置，一路 next 。 安装 Git 工具 自定义安装路径，其余默认配置，一路 next 。 使用 Git 工具安装 Hexo 鼠标右键 Git GUI 选择 Git Bash Here 执行 ： $ npm install hexo-cli -g 构建 Hexo 、Node.js 等初始化环境，$ 是自动生成的。 GitHub 认证配置 username 和 email$ git config --global user.name &quot;username&quot; # 设置用户名 $ git config --global user.email &quot;me@email.com&quot; # 设置邮箱 $ git config --global user.name # 查看用户名 $ git config --global user.email # 查看邮箱 用户名和邮箱是任意的，影响不大。 生成认证指纹$ ls ~/.ssh # 检查认证指纹 ssh key 设置，不区分大小。 $ ssh-keygen -t rsa -C &quot;me@email.com&quot; # C 为大写字母，其后为邮箱 输入 ssh key 保存位置，输入并确认密码，均可以直接回车默认。 $ ls ~/.ssh # 检查 ssh key $ cat ~/.ssh/id_rsa.pub # 抓取配置中的 ssh key，可以先复制下来。 email 是用于生成 ssh key，可以是其他的，也可以理解为生成 ssh key 的一个关键字。 添加 ssh key GitHub 账号的 Personal settings 下 SSH and keys 中添加生成的 ssh key 。 创建仓库 GitHubName：GitHubName.github.io # GitHubName 为 GitHub 用户名，这是约定好的。 创建连接$ ssh -T git@github.com # T 不能为小写 测试本机与 GitHub 之间的 ssh key 连接/是否有效（或是否可以连接） 若第一次配置，最后出现 Are you sure ...（yes/no）? 字样，键入 yes 确认。 若配置过，会直接显示配置的用户名。 快速启动初始化$ hexo init X:\Blog # 在硬盘 X 分区，自定义 Blog 文件夹中初始化。 生成网页$ hexo g # hexo generate 生成静态网页 启动服务$ hexo s # hexo server 启动本地预览服务 本机 localhost:4000 或 http://localhost:4000 可以查看效果，https://localhost:4000 https 协议无法通过。 拉取仓库$ git clone &lt;repo&gt; .deploy/xxx 或者 $ git clone &lt;repo&gt; .deploy/xxx 创建本地仓库，若直接下载解压，没有 .git 忽略文件，可以尝试 git init 指令，效果未知。 repo 是仓库地址 .deploy 和 xxx 是文件夹 创建脚本脚本 1hexo clean # 命名为 .sh 文件 hexo g 可用于清除旧主题，生成新网页。 脚本 2hexo g # 推荐命名为 deploy.sh。 cp -R public/* .deploy/xxx cd .deploy/xxx # 与上述一致 git add . # add 后面有空格和点 git commit -m &quot;update&quot; # master git push origin master # 推送服务器 使用: 先使用脚本 1 用于清除缓存和静态网页，再使用脚本 2 用于向服务器仓库推送。 脚本可自行搭配，注意扩展名，并放到之前初始化过的 X:\Blog 根目录。脚本 3 cd X：/Blog # 切换到网站根目录 hexo clean # 清除 hexo g # 生成 cp -R public/* .deploy/xxx # copy cd .deploy/xxx # 切换目录 git add . # add git commit -m “update” # 提交信息 git push origin master # 推送 更改 X 和 Blog 对应到安装路径根目录 文章创建创建新文件 $ hexo new Hello 生成网页$ hexo g 更换主题 每次更换主题前需要更改网站配置文件 _config.yml 中 themes 节点对应的本地已有的主题名，Blog 安装目录/子目录下执行 $ hexo clean 清除旧主题,再执行静态网页生成 $ hexo g 、本地预览 $ hexo s、部署 $ hexo d 步骤。 themes 文件夹为主题相关的配置，根目录为网站相关的配置。 远程仓库初始化本地$ hexo init 拉取到本地$ git clone remoteRepoAdress # &quot;remoteRepoAdress&quot; 是远程仓库地址 添加多个远程仓库 git remote add origin remoteRepoAdress # 目前操作还有问题，待解决。 git remote set-url origin remoteRepoAdress # 改变 repo，但改变后的后续实现还有问题。 git remote # 查看远程仓库，返回结果一般为 “orgin” 。 git remote -v # 查看远程仓库地址，返回结果为：$ origin remoteRepoAdress (fetch) $ origin remoteRepoAdress (push) 在实践过程中，还有问题没有搞好，找到一个解决方案。 常用指令 $ git clone repo target repo 仓库地址，target 目标地址（本地文件夹）。 $ hexo g 生成部署文件 $ hexo s 开启本地预览服务 ctrl + c 停止本地预览服务 $ hexo d 推送到远程仓库 $ cd x 切换到 x 文件夹，非直接子目录无法切换。 $ cd x: 切换到 x: 分区，任意切换。 $ cd .. 回到上层目录 $ ls 列出所有文件和文件夹 $ ls *.md 列出所有扩展名为 .md 的文件 $ git status 查看当前状态 $ git -a == $ git add 切换 上 下键，切换历史键入记录，与 dos 不同的是：即使是不同的窗口或者窗口关闭过也是可以记录的。 更改主题或主题配置的执行顺序是： 更改根目录 _config.yml 文件 themes 节点 –&gt; $ hexo clean –&gt; $ hexo g –&gt; $ hexo s –&gt; $ hexo d。 本地预览和向服务器推送时，会有延时，多等待一会儿或多刷新几次就可以看到效果了。 常见问题 SSH 认证【英】 公钥【英】 参考及收藏 基于Hexo+GitHub Pages 搭建个人博客教程 基于Hexo-Github—搭建个人博客笔记 最适合新手的 GitHub + Hexo 「大话」博客搭建教程 xuhao 珞神 IIssNan 网站 Node Git Pro Git(中文版) Git 常用操作命令 Git 参考手册 Hexo GitHub Hexo Docs Hexo wiki GitHub Next 主题 Next 配置 博客改造 使用Hexo基于GitHub Pages搭建个人博客 浚宇的博客 浚宇的博客 issue custome logo 底部统计图标 段间距 Blog 秀 本地预览 4000 端口 待改造cloudxns持续集成基于 Hexo 的全自动博客构建部署系统]]></content>
    </entry>

    
  
  
</search>
